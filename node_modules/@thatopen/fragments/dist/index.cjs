"use strict";var ze=Object.defineProperty;var Ee=(a,t,s)=>t in a?ze(a,t,{enumerable:!0,configurable:!0,writable:!0,value:s}):a[t]=s;var B=(a,t,s)=>(Ee(a,typeof t!="symbol"?t+"":t,s),s);Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});const V=require("three");function Ge(a){const t=Object.create(null,{[Symbol.toStringTag]:{value:"Module"}});if(a){for(const s in a)if(s!=="default"){const e=Object.getOwnPropertyDescriptor(a,s);Object.defineProperty(t,s,e.get?e:{enumerable:!0,get:()=>a[s]})}}return t.default=a,Object.freeze(t)}const L=Ge(V);class qs extends L.InstancedMesh{constructor(s,e,i,n){super(s,e,i);B(this,"fragment");B(this,"material");B(this,"geometry");if(Array.isArray(e)||(e=[e]),this.material=e,!s.index)throw new Error("The geometry for fragments must be indexed!");this.geometry=s,this.fragment=n;const o=s.index.count;s.groups.length||s.groups.push({start:0,count:o,materialIndex:0})}exportData(){const s=this.geometry.attributes.position.array,e=this.geometry.attributes.normal.array,i=Array.from(this.geometry.index.array),n=[];for(const f of this.geometry.groups){const l=f.materialIndex||0,{start:b,count:h}=f;n.push(b,h,l)}const o=[];if(Array.isArray(this.material))for(const f of this.material){const l=f.opacity,b=f.transparent?1:0,h=new L.Color(f.color).toArray();o.push(l,b,...h)}const r=Array.from(this.instanceMatrix.array);let c;return this.instanceColor!==null?c=Array.from(this.instanceColor.array):c=[],{position:s,normal:e,index:i,groups:n,materials:o,matrices:r,colors:c}}clone(s){throw new Error("Fragment meshes can't be cloned directly. Use mesh.fragment.clone instead!")}}const Ce=0,Re=1,Ne=2,ce=2,Ps=1.25,ae=1,ws=6*4+4+4,Fs=65535,ke=Math.pow(2,-24),Ss=Symbol("SKIP_GENERATION");function qe(a){return a.index?a.index.count:a.attributes.position.count}function Kt(a){return qe(a)/3}function je(a,t=ArrayBuffer){return a>65535?new Uint32Array(new t(4*a)):new Uint16Array(new t(2*a))}function Ke(a,t){if(!a.index){const s=a.attributes.position.count,e=t.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer,i=je(s,e);a.setIndex(new V.BufferAttribute(i,1));for(let n=0;n<s;n++)i[n]=n}}function Me(a){const t=Kt(a),s=a.drawRange,e=s.start/3,i=(s.start+s.count)/3,n=Math.max(0,e),o=Math.min(t,i)-n;return[{offset:Math.floor(n),count:Math.floor(o)}]}function Pe(a){if(!a.groups||!a.groups.length)return Me(a);const t=[],s=new Set,e=a.drawRange,i=e.start/3,n=(e.start+e.count)/3;for(const r of a.groups){const c=r.start/3,f=(r.start+r.count)/3;s.add(Math.max(i,c)),s.add(Math.min(n,f))}const o=Array.from(s.values()).sort((r,c)=>r-c);for(let r=0;r<o.length-1;r++){const c=o[r],f=o[r+1];t.push({offset:Math.floor(c),count:Math.floor(f-c)})}return t}function $e(a){if(a.groups.length===0)return!1;const t=Kt(a),s=Pe(a).sort((n,o)=>n.offset-o.offset),e=s[s.length-1];e.count=Math.min(t-e.offset,e.count);let i=0;return s.forEach(({count:n})=>i+=n),t!==i}function R(a,t,s){return s.min.x=t[a],s.min.y=t[a+1],s.min.z=t[a+2],s.max.x=t[a+3],s.max.y=t[a+4],s.max.z=t[a+5],s}function He(a){a[0]=a[1]=a[2]=1/0,a[3]=a[4]=a[5]=-1/0}function fe(a){let t=-1,s=-1/0;for(let e=0;e<3;e++){const i=a[e+3]-a[e];i>s&&(s=i,t=e)}return t}function le(a,t){t.set(a)}function he(a,t,s){let e,i;for(let n=0;n<3;n++){const o=n+3;e=a[n],i=t[n],s[n]=e<i?e:i,e=a[o],i=t[o],s[o]=e>i?e:i}}function os(a,t,s){for(let e=0;e<3;e++){const i=t[a+2*e],n=t[a+2*e+1],o=i-n,r=i+n;o<s[e]&&(s[e]=o),r>s[e+3]&&(s[e+3]=r)}}function Ht(a){const t=a[3]-a[0],s=a[4]-a[1],e=a[5]-a[2];return 2*(t*s+s*e+e*t)}function Bs(a,t,s,e,i=null){let n=1/0,o=1/0,r=1/0,c=-1/0,f=-1/0,l=-1/0,b=1/0,h=1/0,u=1/0,_=-1/0,w=-1/0,y=-1/0;const d=i!==null;for(let p=t*6,I=(t+s)*6;p<I;p+=6){const m=a[p+0],g=a[p+1],A=m-g,C=m+g;A<n&&(n=A),C>c&&(c=C),d&&m<b&&(b=m),d&&m>_&&(_=m);const x=a[p+2],M=a[p+3],v=x-M,S=x+M;v<o&&(o=v),S>f&&(f=S),d&&x<h&&(h=x),d&&x>w&&(w=x);const F=a[p+4],P=a[p+5],T=F-P,O=F+P;T<r&&(r=T),O>l&&(l=O),d&&F<u&&(u=F),d&&F>y&&(y=F)}e[0]=n,e[1]=o,e[2]=r,e[3]=c,e[4]=f,e[5]=l,d&&(i[0]=b,i[1]=h,i[2]=u,i[3]=_,i[4]=w,i[5]=y)}function Xe(a,t,s,e){let i=1/0,n=1/0,o=1/0,r=-1/0,c=-1/0,f=-1/0;for(let l=t*6,b=(t+s)*6;l<b;l+=6){const h=a[l+0];h<i&&(i=h),h>r&&(r=h);const u=a[l+2];u<n&&(n=u),u>c&&(c=u);const _=a[l+4];_<o&&(o=_),_>f&&(f=_)}e[0]=i,e[1]=n,e[2]=o,e[3]=r,e[4]=c,e[5]=f}function Ye(a,t){He(t);const s=a.attributes.position,e=a.index?a.index.array:null,i=Kt(a),n=new Float32Array(i*6),o=s.normalized,r=s.array,c=s.offset||0;let f=3;s.isInterleavedBufferAttribute&&(f=s.data.stride);const l=["getX","getY","getZ"];for(let b=0;b<i;b++){const h=b*3,u=b*6;let _=h+0,w=h+1,y=h+2;e&&(_=e[_],w=e[w],y=e[y]),o||(_=_*f+c,w=w*f+c,y=y*f+c);for(let d=0;d<3;d++){let p,I,m;o?(p=s[l[d]](_),I=s[l[d]](w),m=s[l[d]](y)):(p=r[_+d],I=r[w+d],m=r[y+d]);let g=p;I<g&&(g=I),m<g&&(g=m);let A=p;I>A&&(A=I),m>A&&(A=m);const C=(A-g)/2,x=d*2;n[u+x+0]=g+C,n[u+x+1]=C+(Math.abs(g)+C)*ke,g<t[d]&&(t[d]=g),A>t[d+3]&&(t[d+3]=A)}}return n}const at=32,Ze=(a,t)=>a.candidate-t.candidate,mt=new Array(at).fill().map(()=>({count:0,bounds:new Float32Array(6),rightCacheBounds:new Float32Array(6),leftCacheBounds:new Float32Array(6),candidate:0})),rs=new Float32Array(6);function Je(a,t,s,e,i,n){let o=-1,r=0;if(n===Ce)o=fe(t),o!==-1&&(r=(t[o]+t[o+3])/2);else if(n===Re)o=fe(a),o!==-1&&(r=We(s,e,i,o));else if(n===Ne){const c=Ht(a);let f=Ps*i;const l=e*6,b=(e+i)*6;for(let h=0;h<3;h++){const u=t[h],y=(t[h+3]-u)/at;if(i<at/4){const d=[...mt];d.length=i;let p=0;for(let m=l;m<b;m+=6,p++){const g=d[p];g.candidate=s[m+2*h],g.count=0;const{bounds:A,leftCacheBounds:C,rightCacheBounds:x}=g;for(let M=0;M<3;M++)x[M]=1/0,x[M+3]=-1/0,C[M]=1/0,C[M+3]=-1/0,A[M]=1/0,A[M+3]=-1/0;os(m,s,A)}d.sort(Ze);let I=i;for(let m=0;m<I;m++){const g=d[m];for(;m+1<I&&d[m+1].candidate===g.candidate;)d.splice(m+1,1),I--}for(let m=l;m<b;m+=6){const g=s[m+2*h];for(let A=0;A<I;A++){const C=d[A];g>=C.candidate?os(m,s,C.rightCacheBounds):(os(m,s,C.leftCacheBounds),C.count++)}}for(let m=0;m<I;m++){const g=d[m],A=g.count,C=i-g.count,x=g.leftCacheBounds,M=g.rightCacheBounds;let v=0;A!==0&&(v=Ht(x)/c);let S=0;C!==0&&(S=Ht(M)/c);const F=ae+Ps*(v*A+S*C);F<f&&(o=h,f=F,r=g.candidate)}}else{for(let I=0;I<at;I++){const m=mt[I];m.count=0,m.candidate=u+y+I*y;const g=m.bounds;for(let A=0;A<3;A++)g[A]=1/0,g[A+3]=-1/0}for(let I=l;I<b;I+=6){let A=~~((s[I+2*h]-u)/y);A>=at&&(A=at-1);const C=mt[A];C.count++,os(I,s,C.bounds)}const d=mt[at-1];le(d.bounds,d.rightCacheBounds);for(let I=at-2;I>=0;I--){const m=mt[I],g=mt[I+1];he(m.bounds,g.rightCacheBounds,m.rightCacheBounds)}let p=0;for(let I=0;I<at-1;I++){const m=mt[I],g=m.count,A=m.bounds,x=mt[I+1].rightCacheBounds;g!==0&&(p===0?le(A,rs):he(A,rs,rs)),p+=g;let M=0,v=0;p!==0&&(M=Ht(rs)/c);const S=i-p;S!==0&&(v=Ht(x)/c);const F=ae+Ps*(M*p+v*S);F<f&&(o=h,f=F,r=m.candidate)}}}}else console.warn(`MeshBVH: Invalid build strategy value ${n} used.`);return{axis:o,pos:r}}function We(a,t,s,e){let i=0;for(let n=t,o=t+s;n<o;n++)i+=a[n*6+e*2];return i/s}class cs{constructor(){}}function Qe(a,t,s,e,i,n){let o=e,r=e+i-1;const c=n.pos,f=n.axis*2;for(;;){for(;o<=r&&s[o*6+f]<c;)o++;for(;o<=r&&s[r*6+f]>=c;)r--;if(o<r){for(let l=0;l<3;l++){let b=t[o*3+l];t[o*3+l]=t[r*3+l],t[r*3+l]=b}for(let l=0;l<6;l++){let b=s[o*6+l];s[o*6+l]=s[r*6+l],s[r*6+l]=b}o++,r--}else return o}}function ti(a,t,s,e,i,n){let o=e,r=e+i-1;const c=n.pos,f=n.axis*2;for(;;){for(;o<=r&&s[o*6+f]<c;)o++;for(;o<=r&&s[r*6+f]>=c;)r--;if(o<r){let l=a[o];a[o]=a[r],a[r]=l;for(let b=0;b<6;b++){let h=s[o*6+b];s[o*6+b]=s[r*6+b],s[r*6+b]=h}o++,r--}else return o}}function si(a,t){const s=(a.index?a.index.count:a.attributes.position.count)/3,e=s>2**16,i=e?4:2,n=t?new SharedArrayBuffer(s*i):new ArrayBuffer(s*i),o=e?new Uint32Array(n):new Uint16Array(n);for(let r=0,c=o.length;r<c;r++)o[r]=r;return o}function ei(a,t){const s=a.geometry,e=s.index?s.index.array:null,i=t.maxDepth,n=t.verbose,o=t.maxLeafTris,r=t.strategy,c=t.onProgress,f=Kt(s),l=a._indirectBuffer;let b=!1;const h=new Float32Array(6),u=new Float32Array(6),_=Ye(s,h),w=t.indirect?ti:Qe,y=[],d=t.indirect?Me(s):Pe(s);if(d.length===1){const m=d[0],g=new cs;g.boundingData=h,Xe(_,m.offset,m.count,u),I(g,m.offset,m.count,u),y.push(g)}else for(let m of d){const g=new cs;g.boundingData=new Float32Array(6),Bs(_,m.offset,m.count,g.boundingData,u),I(g,m.offset,m.count,u),y.push(g)}return y;function p(m){c&&c(m/f)}function I(m,g,A,C=null,x=0){if(!b&&x>=i&&(b=!0,n&&(console.warn(`MeshBVH: Max depth of ${i} reached when generating BVH. Consider increasing maxDepth.`),console.warn(s))),A<=o||x>=i)return p(g+A),m.offset=g,m.count=A,m;const M=Je(m.boundingData,C,_,g,A,r);if(M.axis===-1)return p(g+A),m.offset=g,m.count=A,m;const v=w(l,e,_,g,A,M);if(v===g||v===g+A)p(g+A),m.offset=g,m.count=A;else{m.splitAxis=M.axis;const S=new cs,F=g,P=v-g;m.left=S,S.boundingData=new Float32Array(6),Bs(_,F,P,S.boundingData,u),I(S,F,P,u,x+1);const T=new cs,O=v,D=A-P;m.right=T,T.boundingData=new Float32Array(6),Bs(_,O,D,T.boundingData,u),I(T,O,D,u,x+1)}return m}}function ii(a,t){const s=a.geometry;t.indirect&&(a._indirectBuffer=si(s,t.useSharedArrayBuffer),$e(s)&&!t.verbose&&console.warn('MeshBVH: Provided geometry contains groups that do not fully span the vertex contents while using the "indirect" option. BVH may incorrectly report intersections on unrendered portions of the geometry.')),a._indirectBuffer||Ke(s,t);const e=ei(a,t);let i,n,o;const r=[],c=t.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer;for(let b=0;b<e.length;b++){const h=e[b];let u=f(h);const _=new c(ws*u);i=new Float32Array(_),n=new Uint32Array(_),o=new Uint16Array(_),l(0,h),r.push(_)}a._roots=r;return;function f(b){return b.count?1:1+f(b.left)+f(b.right)}function l(b,h){const u=b/4,_=b/2,w=!!h.count,y=h.boundingData;for(let d=0;d<6;d++)i[u+d]=y[d];if(w){const d=h.offset,p=h.count;return n[u+6]=d,o[_+14]=p,o[_+15]=Fs,b+ws}else{const d=h.left,p=h.right,I=h.splitAxis;let m;if(m=l(b+ws,d),m/4>Math.pow(2,32))throw new Error("MeshBVH: Cannot store child pointer greater than 32 bits.");return n[u+6]=m/4,m=l(m,p),n[u+7]=I,m}}}class ut{constructor(){this.min=1/0,this.max=-1/0}setFromPointsField(t,s){let e=1/0,i=-1/0;for(let n=0,o=t.length;n<o;n++){const c=t[n][s];e=c<e?c:e,i=c>i?c:i}this.min=e,this.max=i}setFromPoints(t,s){let e=1/0,i=-1/0;for(let n=0,o=s.length;n<o;n++){const r=s[n],c=t.dot(r);e=c<e?c:e,i=c>i?c:i}this.min=e,this.max=i}isSeparated(t){return this.min>t.max||t.min>this.max}}ut.prototype.setFromBox=function(){const a=new V.Vector3;return function(s,e){const i=e.min,n=e.max;let o=1/0,r=-1/0;for(let c=0;c<=1;c++)for(let f=0;f<=1;f++)for(let l=0;l<=1;l++){a.x=i.x*c+n.x*(1-c),a.y=i.y*f+n.y*(1-f),a.z=i.z*l+n.z*(1-l);const b=s.dot(a);o=Math.min(b,o),r=Math.max(b,r)}this.min=o,this.max=r}}();const ni=function(){const a=new V.Vector3,t=new V.Vector3,s=new V.Vector3;return function(i,n,o){const r=i.start,c=a,f=n.start,l=t;s.subVectors(r,f),a.subVectors(i.end,i.start),t.subVectors(n.end,n.start);const b=s.dot(l),h=l.dot(c),u=l.dot(l),_=s.dot(c),y=c.dot(c)*u-h*h;let d,p;y!==0?d=(b*h-_*u)/y:d=0,p=(b+d*h)/u,o.x=d,o.y=p}}(),se=function(){const a=new V.Vector2,t=new V.Vector3,s=new V.Vector3;return function(i,n,o,r){ni(i,n,a);let c=a.x,f=a.y;if(c>=0&&c<=1&&f>=0&&f<=1){i.at(c,o),n.at(f,r);return}else if(c>=0&&c<=1){f<0?n.at(0,r):n.at(1,r),i.closestPointToPoint(r,!0,o);return}else if(f>=0&&f<=1){c<0?i.at(0,o):i.at(1,o),n.closestPointToPoint(o,!0,r);return}else{let l;c<0?l=i.start:l=i.end;let b;f<0?b=n.start:b=n.end;const h=t,u=s;if(i.closestPointToPoint(b,!0,t),n.closestPointToPoint(l,!0,s),h.distanceToSquared(b)<=u.distanceToSquared(l)){o.copy(h),r.copy(b);return}else{o.copy(l),r.copy(u);return}}}}(),oi=function(){const a=new V.Vector3,t=new V.Vector3,s=new V.Plane,e=new V.Line3;return function(n,o){const{radius:r,center:c}=n,{a:f,b:l,c:b}=o;if(e.start=f,e.end=l,e.closestPointToPoint(c,!0,a).distanceTo(c)<=r||(e.start=f,e.end=b,e.closestPointToPoint(c,!0,a).distanceTo(c)<=r)||(e.start=l,e.end=b,e.closestPointToPoint(c,!0,a).distanceTo(c)<=r))return!0;const w=o.getPlane(s);if(Math.abs(w.distanceToPoint(c))<=r){const d=w.projectPoint(c,t);if(o.containsPoint(d))return!0}return!1}}(),ri=1e-15;function Ts(a){return Math.abs(a)<ri}class ot extends V.Triangle{constructor(...t){super(...t),this.isExtendedTriangle=!0,this.satAxes=new Array(4).fill().map(()=>new V.Vector3),this.satBounds=new Array(4).fill().map(()=>new ut),this.points=[this.a,this.b,this.c],this.sphere=new V.Sphere,this.plane=new V.Plane,this.needsUpdate=!0}intersectsSphere(t){return oi(t,this)}update(){const t=this.a,s=this.b,e=this.c,i=this.points,n=this.satAxes,o=this.satBounds,r=n[0],c=o[0];this.getNormal(r),c.setFromPoints(r,i);const f=n[1],l=o[1];f.subVectors(t,s),l.setFromPoints(f,i);const b=n[2],h=o[2];b.subVectors(s,e),h.setFromPoints(b,i);const u=n[3],_=o[3];u.subVectors(e,t),_.setFromPoints(u,i),this.sphere.setFromPoints(this.points),this.plane.setFromNormalAndCoplanarPoint(r,t),this.needsUpdate=!1}}ot.prototype.closestPointToSegment=function(){const a=new V.Vector3,t=new V.Vector3,s=new V.Line3;return function(i,n=null,o=null){const{start:r,end:c}=i,f=this.points;let l,b=1/0;for(let h=0;h<3;h++){const u=(h+1)%3;s.start.copy(f[h]),s.end.copy(f[u]),se(s,i,a,t),l=a.distanceToSquared(t),l<b&&(b=l,n&&n.copy(a),o&&o.copy(t))}return this.closestPointToPoint(r,a),l=r.distanceToSquared(a),l<b&&(b=l,n&&n.copy(a),o&&o.copy(r)),this.closestPointToPoint(c,a),l=c.distanceToSquared(a),l<b&&(b=l,n&&n.copy(a),o&&o.copy(c)),Math.sqrt(b)}}();ot.prototype.intersectsTriangle=function(){const a=new ot,t=new Array(3),s=new Array(3),e=new ut,i=new ut,n=new V.Vector3,o=new V.Vector3,r=new V.Vector3,c=new V.Vector3,f=new V.Vector3,l=new V.Line3,b=new V.Line3,h=new V.Line3,u=new V.Vector3;function _(w,y,d){const p=w.points;let I=0,m=-1;for(let g=0;g<3;g++){const{start:A,end:C}=l;A.copy(p[g]),C.copy(p[(g+1)%3]),l.delta(o);const x=Ts(y.distanceToPoint(A));if(Ts(y.normal.dot(o))&&x){d.copy(l),I=2;break}const M=y.intersectLine(l,u);if(!M&&x&&u.copy(A),(M||x)&&!Ts(u.distanceTo(C))){if(I<=1)(I===1?d.start:d.end).copy(u),x&&(m=I);else if(I>=2){(m===1?d.start:d.end).copy(u),I=2;break}if(I++,I===2&&m===-1)break}}return I}return function(y,d=null,p=!1){this.needsUpdate&&this.update(),y.isExtendedTriangle?y.needsUpdate&&y.update():(a.copy(y),a.update(),y=a);const I=this.plane,m=y.plane;if(Math.abs(I.normal.dot(m.normal))>1-1e-10){const g=this.satBounds,A=this.satAxes;s[0]=y.a,s[1]=y.b,s[2]=y.c;for(let M=0;M<4;M++){const v=g[M],S=A[M];if(e.setFromPoints(S,s),v.isSeparated(e))return!1}const C=y.satBounds,x=y.satAxes;t[0]=this.a,t[1]=this.b,t[2]=this.c;for(let M=0;M<4;M++){const v=C[M],S=x[M];if(e.setFromPoints(S,t),v.isSeparated(e))return!1}for(let M=0;M<4;M++){const v=A[M];for(let S=0;S<4;S++){const F=x[S];if(n.crossVectors(v,F),e.setFromPoints(n,t),i.setFromPoints(n,s),e.isSeparated(i))return!1}}return d&&(p||console.warn("ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0."),d.start.set(0,0,0),d.end.set(0,0,0)),!0}else{const g=_(this,m,b);if(g===1&&y.containsPoint(b.end))return d&&(d.start.copy(b.end),d.end.copy(b.end)),!0;if(g!==2)return!1;const A=_(y,I,h);if(A===1&&this.containsPoint(h.end))return d&&(d.start.copy(h.end),d.end.copy(h.end)),!0;if(A!==2)return!1;if(b.delta(r),h.delta(c),r.dot(c)<0){let P=h.start;h.start=h.end,h.end=P}const C=b.start.dot(r),x=b.end.dot(r),M=h.start.dot(r),v=h.end.dot(r),S=x<M,F=C<v;return C!==v&&M!==x&&S===F?!1:(d&&(f.subVectors(b.start,h.start),f.dot(r)>0?d.start.copy(b.start):d.start.copy(h.start),f.subVectors(b.end,h.end),f.dot(r)<0?d.end.copy(b.end):d.end.copy(h.end)),!0)}}}();ot.prototype.distanceToPoint=function(){const a=new V.Vector3;return function(s){return this.closestPointToPoint(s,a),s.distanceTo(a)}}();ot.prototype.distanceToTriangle=function(){const a=new V.Vector3,t=new V.Vector3,s=["a","b","c"],e=new V.Line3,i=new V.Line3;return function(o,r=null,c=null){const f=r||c?e:null;if(this.intersectsTriangle(o,f))return(r||c)&&(r&&f.getCenter(r),c&&f.getCenter(c)),0;let l=1/0;for(let b=0;b<3;b++){let h;const u=s[b],_=o[u];this.closestPointToPoint(_,a),h=_.distanceToSquared(a),h<l&&(l=h,r&&r.copy(a),c&&c.copy(_));const w=this[u];o.closestPointToPoint(w,a),h=w.distanceToSquared(a),h<l&&(l=h,r&&r.copy(w),c&&c.copy(a))}for(let b=0;b<3;b++){const h=s[b],u=s[(b+1)%3];e.set(this[h],this[u]);for(let _=0;_<3;_++){const w=s[_],y=s[(_+1)%3];i.set(o[w],o[y]),se(e,i,a,t);const d=a.distanceToSquared(t);d<l&&(l=d,r&&r.copy(a),c&&c.copy(t))}}return Math.sqrt(l)}}();class H{constructor(t,s,e){this.isOrientedBox=!0,this.min=new V.Vector3,this.max=new V.Vector3,this.matrix=new V.Matrix4,this.invMatrix=new V.Matrix4,this.points=new Array(8).fill().map(()=>new V.Vector3),this.satAxes=new Array(3).fill().map(()=>new V.Vector3),this.satBounds=new Array(3).fill().map(()=>new ut),this.alignedSatBounds=new Array(3).fill().map(()=>new ut),this.needsUpdate=!1,t&&this.min.copy(t),s&&this.max.copy(s),e&&this.matrix.copy(e)}set(t,s,e){this.min.copy(t),this.max.copy(s),this.matrix.copy(e),this.needsUpdate=!0}copy(t){this.min.copy(t.min),this.max.copy(t.max),this.matrix.copy(t.matrix),this.needsUpdate=!0}}H.prototype.update=function(){return function(){const t=this.matrix,s=this.min,e=this.max,i=this.points;for(let f=0;f<=1;f++)for(let l=0;l<=1;l++)for(let b=0;b<=1;b++){const h=1*f|2*l|4*b,u=i[h];u.x=f?e.x:s.x,u.y=l?e.y:s.y,u.z=b?e.z:s.z,u.applyMatrix4(t)}const n=this.satBounds,o=this.satAxes,r=i[0];for(let f=0;f<3;f++){const l=o[f],b=n[f],h=1<<f,u=i[h];l.subVectors(r,u),b.setFromPoints(l,i)}const c=this.alignedSatBounds;c[0].setFromPointsField(i,"x"),c[1].setFromPointsField(i,"y"),c[2].setFromPointsField(i,"z"),this.invMatrix.copy(this.matrix).invert(),this.needsUpdate=!1}}();H.prototype.intersectsBox=function(){const a=new ut;return function(s){this.needsUpdate&&this.update();const e=s.min,i=s.max,n=this.satBounds,o=this.satAxes,r=this.alignedSatBounds;if(a.min=e.x,a.max=i.x,r[0].isSeparated(a)||(a.min=e.y,a.max=i.y,r[1].isSeparated(a))||(a.min=e.z,a.max=i.z,r[2].isSeparated(a)))return!1;for(let c=0;c<3;c++){const f=o[c],l=n[c];if(a.setFromBox(f,s),l.isSeparated(a))return!1}return!0}}();H.prototype.intersectsTriangle=function(){const a=new ot,t=new Array(3),s=new ut,e=new ut,i=new V.Vector3;return function(o){this.needsUpdate&&this.update(),o.isExtendedTriangle?o.needsUpdate&&o.update():(a.copy(o),a.update(),o=a);const r=this.satBounds,c=this.satAxes;t[0]=o.a,t[1]=o.b,t[2]=o.c;for(let h=0;h<3;h++){const u=r[h],_=c[h];if(s.setFromPoints(_,t),u.isSeparated(s))return!1}const f=o.satBounds,l=o.satAxes,b=this.points;for(let h=0;h<3;h++){const u=f[h],_=l[h];if(s.setFromPoints(_,b),u.isSeparated(s))return!1}for(let h=0;h<3;h++){const u=c[h];for(let _=0;_<4;_++){const w=l[_];if(i.crossVectors(u,w),s.setFromPoints(i,t),e.setFromPoints(i,b),s.isSeparated(e))return!1}}return!0}}();H.prototype.closestPointToPoint=function(){return function(t,s){return this.needsUpdate&&this.update(),s.copy(t).applyMatrix4(this.invMatrix).clamp(this.min,this.max).applyMatrix4(this.matrix),s}}();H.prototype.distanceToPoint=function(){const a=new V.Vector3;return function(s){return this.closestPointToPoint(s,a),s.distanceTo(a)}}();H.prototype.distanceToBox=function(){const a=["x","y","z"],t=new Array(12).fill().map(()=>new V.Line3),s=new Array(12).fill().map(()=>new V.Line3),e=new V.Vector3,i=new V.Vector3;return function(o,r=0,c=null,f=null){if(this.needsUpdate&&this.update(),this.intersectsBox(o))return(c||f)&&(o.getCenter(i),this.closestPointToPoint(i,e),o.closestPointToPoint(e,i),c&&c.copy(e),f&&f.copy(i)),0;const l=r*r,b=o.min,h=o.max,u=this.points;let _=1/0;for(let y=0;y<8;y++){const d=u[y];i.copy(d).clamp(b,h);const p=d.distanceToSquared(i);if(p<_&&(_=p,c&&c.copy(d),f&&f.copy(i),p<l))return Math.sqrt(p)}let w=0;for(let y=0;y<3;y++)for(let d=0;d<=1;d++)for(let p=0;p<=1;p++){const I=(y+1)%3,m=(y+2)%3,g=d<<I|p<<m,A=1<<y|d<<I|p<<m,C=u[g],x=u[A];t[w].set(C,x);const v=a[y],S=a[I],F=a[m],P=s[w],T=P.start,O=P.end;T[v]=b[v],T[S]=d?b[S]:h[S],T[F]=p?b[F]:h[S],O[v]=h[v],O[S]=d?b[S]:h[S],O[F]=p?b[F]:h[S],w++}for(let y=0;y<=1;y++)for(let d=0;d<=1;d++)for(let p=0;p<=1;p++){i.x=y?h.x:b.x,i.y=d?h.y:b.y,i.z=p?h.z:b.z,this.closestPointToPoint(i,e);const I=i.distanceToSquared(e);if(I<_&&(_=I,c&&c.copy(e),f&&f.copy(i),I<l))return Math.sqrt(I)}for(let y=0;y<12;y++){const d=t[y];for(let p=0;p<12;p++){const I=s[p];se(d,I,e,i);const m=e.distanceToSquared(i);if(m<_&&(_=m,c&&c.copy(e),f&&f.copy(i),m<l))return Math.sqrt(m)}}return Math.sqrt(_)}}();class ee{constructor(t){this._getNewPrimitive=t,this._primitives=[]}getPrimitive(){const t=this._primitives;return t.length===0?this._getNewPrimitive():t.pop()}releasePrimitive(t){this._primitives.push(t)}}class ci extends ee{constructor(){super(()=>new ot)}}const Q=new ci;function Z(a,t){return t[a+15]===65535}function J(a,t){return t[a+6]}function tt(a,t){return t[a+14]}function st(a){return a+8}function et(a,t){return t[a+6]}function Se(a,t){return t[a+7]}class ai{constructor(){this.float32Array=null,this.uint16Array=null,this.uint32Array=null;const t=[];let s=null;this.setBuffer=e=>{s&&t.push(s),s=e,this.float32Array=new Float32Array(e),this.uint16Array=new Uint16Array(e),this.uint32Array=new Uint32Array(e)},this.clearBuffer=()=>{s=null,this.float32Array=null,this.uint16Array=null,this.uint32Array=null,t.length!==0&&this.setBuffer(t.pop())}}}const G=new ai;let wt,jt;const Lt=[],as=new ee(()=>new V.Box3);function fi(a,t,s,e,i,n){wt=as.getPrimitive(),jt=as.getPrimitive(),Lt.push(wt,jt),G.setBuffer(a._roots[t]);const o=js(0,a.geometry,s,e,i,n);G.clearBuffer(),as.releasePrimitive(wt),as.releasePrimitive(jt),Lt.pop(),Lt.pop();const r=Lt.length;return r>0&&(jt=Lt[r-1],wt=Lt[r-2]),o}function js(a,t,s,e,i=null,n=0,o=0){const{float32Array:r,uint16Array:c,uint32Array:f}=G;let l=a*2;if(Z(l,c)){const h=J(a,f),u=tt(l,c);return R(a,r,wt),e(h,u,!1,o,n+a,wt)}else{let v=function(F){const{uint16Array:P,uint32Array:T}=G;let O=F*2;for(;!Z(O,P);)F=st(F),O=F*2;return J(F,T)},S=function(F){const{uint16Array:P,uint32Array:T}=G;let O=F*2;for(;!Z(O,P);)F=et(F,T),O=F*2;return J(F,T)+tt(O,P)};const h=st(a),u=et(a,f);let _=h,w=u,y,d,p,I;if(i&&(p=wt,I=jt,R(_,r,p),R(w,r,I),y=i(p),d=i(I),d<y)){_=u,w=h;const F=y;y=d,d=F,p=I}p||(p=wt,R(_,r,p));const m=Z(_*2,c),g=s(p,m,y,o+1,n+_);let A;if(g===ce){const F=v(_),T=S(_)-F;A=e(F,T,!0,o+1,n+_,p)}else A=g&&js(_,t,s,e,i,n,o+1);if(A)return!0;I=jt,R(w,r,I);const C=Z(w*2,c),x=s(I,C,d,o+1,n+w);let M;if(x===ce){const F=v(w),T=S(w)-F;M=e(F,T,!0,o+1,n+w,I)}else M=x&&js(w,t,s,e,i,n,o+1);return!!M}}const Xt=new V.Vector3,Os=new V.Vector3;function li(a,t,s={},e=0,i=1/0){const n=e*e,o=i*i;let r=1/0,c=null;if(a.shapecast({boundsTraverseOrder:l=>(Xt.copy(t).clamp(l.min,l.max),Xt.distanceToSquared(t)),intersectsBounds:(l,b,h)=>h<r&&h<o,intersectsTriangle:(l,b)=>{l.closestPointToPoint(t,Xt);const h=t.distanceToSquared(Xt);return h<r&&(Os.copy(Xt),r=h,c=b),h<n}}),r===1/0)return null;const f=Math.sqrt(r);return s.point?s.point.copy(Os):s.point=Os.clone(),s.distance=f,s.faceIndex=c,s}const Dt=new V.Vector3,Ut=new V.Vector3,zt=new V.Vector3,fs=new V.Vector2,ls=new V.Vector2,hs=new V.Vector2,be=new V.Vector3,ue=new V.Vector3,de=new V.Vector3,bs=new V.Vector3;function hi(a,t,s,e,i,n){let o;return n===V.BackSide?o=a.intersectTriangle(e,s,t,!0,i):o=a.intersectTriangle(t,s,e,n!==V.DoubleSide,i),o===null?null:{distance:a.origin.distanceTo(i),point:i.clone()}}function bi(a,t,s,e,i,n,o,r,c){Dt.fromBufferAttribute(t,n),Ut.fromBufferAttribute(t,o),zt.fromBufferAttribute(t,r);const f=hi(a,Dt,Ut,zt,bs,c);if(f){e&&(fs.fromBufferAttribute(e,n),ls.fromBufferAttribute(e,o),hs.fromBufferAttribute(e,r),f.uv=V.Triangle.getInterpolation(bs,Dt,Ut,zt,fs,ls,hs,new V.Vector2)),i&&(fs.fromBufferAttribute(i,n),ls.fromBufferAttribute(i,o),hs.fromBufferAttribute(i,r),f.uv1=V.Triangle.getInterpolation(bs,Dt,Ut,zt,fs,ls,hs,new V.Vector2)),s&&(be.fromBufferAttribute(s,n),ue.fromBufferAttribute(s,o),de.fromBufferAttribute(s,r),f.normal=V.Triangle.getInterpolation(bs,Dt,Ut,zt,be,ue,de,new V.Vector3),f.normal.dot(a.direction)>0&&f.normal.multiplyScalar(-1));const l={a:n,b:o,c:r,normal:new V.Vector3,materialIndex:0};V.Triangle.getNormal(Dt,Ut,zt,l.normal),f.face=l,f.faceIndex=n}return f}function Cs(a,t,s,e,i){const n=e*3;let o=n+0,r=n+1,c=n+2;const f=a.index;a.index&&(o=f.getX(o),r=f.getX(r),c=f.getX(c));const{position:l,normal:b,uv:h,uv1:u}=a.attributes,_=bi(s,l,b,h,u,o,r,c,t);return _?(_.faceIndex=e,i&&i.push(_),_):null}function k(a,t,s,e){const i=a.a,n=a.b,o=a.c;let r=t,c=t+1,f=t+2;s&&(r=s.getX(r),c=s.getX(c),f=s.getX(f)),i.x=e.getX(r),i.y=e.getY(r),i.z=e.getZ(r),n.x=e.getX(c),n.y=e.getY(c),n.z=e.getZ(c),o.x=e.getX(f),o.y=e.getY(f),o.z=e.getZ(f)}function ui(a,t,s,e,i,n){const{geometry:o,_indirectBuffer:r}=a;for(let c=e,f=e+i;c<f;c++)Cs(o,t,s,c,n)}function di(a,t,s,e,i){const{geometry:n,_indirectBuffer:o}=a;let r=1/0,c=null;for(let f=e,l=e+i;f<l;f++){let b;b=Cs(n,t,s,f),b&&b.distance<r&&(c=b,r=b.distance)}return c}function _i(a,t,s,e,i,n,o){const{geometry:r}=s,{index:c}=r,f=r.attributes.position;for(let l=a,b=t+a;l<b;l++){let h;if(h=l,k(o,h*3,c,f),o.needsUpdate=!0,e(o,h,i,n))return!0}return!1}function pi(a,t=null){t&&Array.isArray(t)&&(t=new Set(t));const s=a.geometry,e=s.index?s.index.array:null,i=s.attributes.position;let n,o,r,c,f=0;const l=a._roots;for(let h=0,u=l.length;h<u;h++)n=l[h],o=new Uint32Array(n),r=new Uint16Array(n),c=new Float32Array(n),b(0,f),f+=n.byteLength;function b(h,u,_=!1){const w=h*2;if(r[w+15]===Fs){const d=o[h+6],p=r[w+14];let I=1/0,m=1/0,g=1/0,A=-1/0,C=-1/0,x=-1/0;for(let M=3*d,v=3*(d+p);M<v;M++){let S=e[M];const F=i.getX(S),P=i.getY(S),T=i.getZ(S);F<I&&(I=F),F>A&&(A=F),P<m&&(m=P),P>C&&(C=P),T<g&&(g=T),T>x&&(x=T)}return c[h+0]!==I||c[h+1]!==m||c[h+2]!==g||c[h+3]!==A||c[h+4]!==C||c[h+5]!==x?(c[h+0]=I,c[h+1]=m,c[h+2]=g,c[h+3]=A,c[h+4]=C,c[h+5]=x,!0):!1}else{const d=h+8,p=o[h+6],I=d+u,m=p+u;let g=_,A=!1,C=!1;t?g||(A=t.has(I),C=t.has(m),g=!A&&!C):(A=!0,C=!0);const x=g||A,M=g||C;let v=!1;x&&(v=b(d,u,g));let S=!1;M&&(S=b(p,u,g));const F=v||S;if(F)for(let P=0;P<3;P++){const T=d+P,O=p+P,D=c[T],$=c[T+3],X=c[O],Y=c[O+3];c[h+P]=D<X?D:X,c[h+P+3]=$>Y?$:Y}return F}}}const _e=new V.Box3;function xt(a,t,s,e){return R(a,t,_e),s.intersectBox(_e,e)}function mi(a,t,s,e,i,n){const{geometry:o,_indirectBuffer:r}=a;for(let c=e,f=e+i;c<f;c++){let l=r?r[c]:c;Cs(o,t,s,l,n)}}function yi(a,t,s,e,i){const{geometry:n,_indirectBuffer:o}=a;let r=1/0,c=null;for(let f=e,l=e+i;f<l;f++){let b;b=Cs(n,t,s,o?o[f]:f),b&&b.distance<r&&(c=b,r=b.distance)}return c}function gi(a,t,s,e,i,n,o){const{geometry:r}=s,{index:c}=r,f=r.attributes.position;for(let l=a,b=t+a;l<b;l++){let h;if(h=s.resolveTriangleIndex(l),k(o,h*3,c,f),o.needsUpdate=!0,e(o,h,i,n))return!0}return!1}const pe=new V.Vector3;function Ii(a,t,s,e,i){G.setBuffer(a._roots[t]),Ks(0,a,s,e,i),G.clearBuffer()}function Ks(a,t,s,e,i){const{float32Array:n,uint16Array:o,uint32Array:r}=G,c=a*2;if(Z(c,o)){const l=J(a,r),b=tt(c,o);ui(t,s,e,l,b,i)}else{const l=st(a);xt(l,n,e,pe)&&Ks(l,t,s,e,i);const b=et(a,r);xt(b,n,e,pe)&&Ks(b,t,s,e,i)}}const me=new V.Vector3,wi=["x","y","z"];function xi(a,t,s,e){G.setBuffer(a._roots[t]);const i=$s(0,a,s,e);return G.clearBuffer(),i}function $s(a,t,s,e){const{float32Array:i,uint16Array:n,uint32Array:o}=G;let r=a*2;if(Z(r,n)){const f=J(a,o),l=tt(r,n);return di(t,s,e,f,l)}else{const f=Se(a,o),l=wi[f],h=e.direction[l]>=0;let u,_;h?(u=st(a),_=et(a,o)):(u=et(a,o),_=st(a));const y=xt(u,i,e,me)?$s(u,t,s,e):null;if(y){const I=y.point[l];if(h?I<=i[_+f]:I>=i[_+f+3])return y}const p=xt(_,i,e,me)?$s(_,t,s,e):null;return y&&p?y.distance<=p.distance?y:p:y||p||null}}const us=new V.Box3,Et=new ot,Gt=new ot,Yt=new V.Matrix4,ye=new H,ds=new H;function Ai(a,t,s,e){G.setBuffer(a._roots[t]);const i=Hs(0,a,s,e);return G.clearBuffer(),i}function Hs(a,t,s,e,i=null){const{float32Array:n,uint16Array:o,uint32Array:r}=G;let c=a*2;if(i===null&&(s.boundingBox||s.computeBoundingBox(),ye.set(s.boundingBox.min,s.boundingBox.max,e),i=ye),Z(c,o)){const l=t.geometry,b=l.index,h=l.attributes.position,u=s.index,_=s.attributes.position,w=J(a,r),y=tt(c,o);if(Yt.copy(e).invert(),s.boundsTree)return R(a,n,ds),ds.matrix.copy(Yt),ds.needsUpdate=!0,s.boundsTree.shapecast({intersectsBounds:p=>ds.intersectsBox(p),intersectsTriangle:p=>{p.a.applyMatrix4(e),p.b.applyMatrix4(e),p.c.applyMatrix4(e),p.needsUpdate=!0;for(let I=w*3,m=(y+w)*3;I<m;I+=3)if(k(Gt,I,b,h),Gt.needsUpdate=!0,p.intersectsTriangle(Gt))return!0;return!1}});for(let d=w*3,p=(y+w)*3;d<p;d+=3){k(Et,d,b,h),Et.a.applyMatrix4(Yt),Et.b.applyMatrix4(Yt),Et.c.applyMatrix4(Yt),Et.needsUpdate=!0;for(let I=0,m=u.count;I<m;I+=3)if(k(Gt,I,u,_),Gt.needsUpdate=!0,Et.intersectsTriangle(Gt))return!0}}else{const l=a+8,b=r[a+6];return R(l,n,us),!!(i.intersectsBox(us)&&Hs(l,t,s,e,i)||(R(b,n,us),i.intersectsBox(us)&&Hs(b,t,s,e,i)))}}const _s=new V.Matrix4,Ls=new H,Zt=new H,vi=new V.Vector3,Vi=new V.Vector3,Fi=new V.Vector3,Ci=new V.Vector3;function Mi(a,t,s,e={},i={},n=0,o=1/0){t.boundingBox||t.computeBoundingBox(),Ls.set(t.boundingBox.min,t.boundingBox.max,s),Ls.needsUpdate=!0;const r=a.geometry,c=r.attributes.position,f=r.index,l=t.attributes.position,b=t.index,h=Q.getPrimitive(),u=Q.getPrimitive();let _=vi,w=Vi,y=null,d=null;i&&(y=Fi,d=Ci);let p=1/0,I=null,m=null;return _s.copy(s).invert(),Zt.matrix.copy(_s),a.shapecast({boundsTraverseOrder:g=>Ls.distanceToBox(g),intersectsBounds:(g,A,C)=>C<p&&C<o?(A&&(Zt.min.copy(g.min),Zt.max.copy(g.max),Zt.needsUpdate=!0),!0):!1,intersectsRange:(g,A)=>{if(t.boundsTree)return t.boundsTree.shapecast({boundsTraverseOrder:x=>Zt.distanceToBox(x),intersectsBounds:(x,M,v)=>v<p&&v<o,intersectsRange:(x,M)=>{for(let v=x,S=x+M;v<S;v++){k(u,3*v,b,l),u.a.applyMatrix4(s),u.b.applyMatrix4(s),u.c.applyMatrix4(s),u.needsUpdate=!0;for(let F=g,P=g+A;F<P;F++){k(h,3*F,f,c),h.needsUpdate=!0;const T=h.distanceToTriangle(u,_,y);if(T<p&&(w.copy(_),d&&d.copy(y),p=T,I=F,m=v),T<n)return!0}}}});{const C=Kt(t);for(let x=0,M=C;x<M;x++){k(u,3*x,b,l),u.a.applyMatrix4(s),u.b.applyMatrix4(s),u.c.applyMatrix4(s),u.needsUpdate=!0;for(let v=g,S=g+A;v<S;v++){k(h,3*v,f,c),h.needsUpdate=!0;const F=h.distanceToTriangle(u,_,y);if(F<p&&(w.copy(_),d&&d.copy(y),p=F,I=v,m=x),F<n)return!0}}}}}),Q.releasePrimitive(h),Q.releasePrimitive(u),p===1/0?null:(e.point?e.point.copy(w):e.point=w.clone(),e.distance=p,e.faceIndex=I,i&&(i.point?i.point.copy(d):i.point=d.clone(),i.point.applyMatrix4(_s),w.applyMatrix4(_s),i.distance=w.sub(i.point).length(),i.faceIndex=m),e)}function Pi(a,t=null){t&&Array.isArray(t)&&(t=new Set(t));const s=a.geometry,e=s.index?s.index.array:null,i=s.attributes.position;let n,o,r,c,f=0;const l=a._roots;for(let h=0,u=l.length;h<u;h++)n=l[h],o=new Uint32Array(n),r=new Uint16Array(n),c=new Float32Array(n),b(0,f),f+=n.byteLength;function b(h,u,_=!1){const w=h*2;if(r[w+15]===Fs){const d=o[h+6],p=r[w+14];let I=1/0,m=1/0,g=1/0,A=-1/0,C=-1/0,x=-1/0;for(let M=d,v=d+p;M<v;M++){const S=3*a.resolveTriangleIndex(M);for(let F=0;F<3;F++){let P=S+F;P=e?e[P]:P;const T=i.getX(P),O=i.getY(P),D=i.getZ(P);T<I&&(I=T),T>A&&(A=T),O<m&&(m=O),O>C&&(C=O),D<g&&(g=D),D>x&&(x=D)}}return c[h+0]!==I||c[h+1]!==m||c[h+2]!==g||c[h+3]!==A||c[h+4]!==C||c[h+5]!==x?(c[h+0]=I,c[h+1]=m,c[h+2]=g,c[h+3]=A,c[h+4]=C,c[h+5]=x,!0):!1}else{const d=h+8,p=o[h+6],I=d+u,m=p+u;let g=_,A=!1,C=!1;t?g||(A=t.has(I),C=t.has(m),g=!A&&!C):(A=!0,C=!0);const x=g||A,M=g||C;let v=!1;x&&(v=b(d,u,g));let S=!1;M&&(S=b(p,u,g));const F=v||S;if(F)for(let P=0;P<3;P++){const T=d+P,O=p+P,D=c[T],$=c[T+3],X=c[O],Y=c[O+3];c[h+P]=D<X?D:X,c[h+P+3]=$>Y?$:Y}return F}}}const ge=new V.Vector3;function Si(a,t,s,e,i){G.setBuffer(a._roots[t]),Xs(0,a,s,e,i),G.clearBuffer()}function Xs(a,t,s,e,i){const{float32Array:n,uint16Array:o,uint32Array:r}=G,c=a*2;if(Z(c,o)){const l=J(a,r),b=tt(c,o);mi(t,s,e,l,b,i)}else{const l=st(a);xt(l,n,e,ge)&&Xs(l,t,s,e,i);const b=et(a,r);xt(b,n,e,ge)&&Xs(b,t,s,e,i)}}const Ie=new V.Vector3,Bi=["x","y","z"];function Ti(a,t,s,e){G.setBuffer(a._roots[t]);const i=Ys(0,a,s,e);return G.clearBuffer(),i}function Ys(a,t,s,e){const{float32Array:i,uint16Array:n,uint32Array:o}=G;let r=a*2;if(Z(r,n)){const f=J(a,o),l=tt(r,n);return yi(t,s,e,f,l)}else{const f=Se(a,o),l=Bi[f],h=e.direction[l]>=0;let u,_;h?(u=st(a),_=et(a,o)):(u=et(a,o),_=st(a));const y=xt(u,i,e,Ie)?Ys(u,t,s,e):null;if(y){const I=y.point[l];if(h?I<=i[_+f]:I>=i[_+f+3])return y}const p=xt(_,i,e,Ie)?Ys(_,t,s,e):null;return y&&p?y.distance<=p.distance?y:p:y||p||null}}const ps=new V.Box3,Rt=new ot,Nt=new ot,Jt=new V.Matrix4,we=new H,ms=new H;function Oi(a,t,s,e){G.setBuffer(a._roots[t]);const i=Zs(0,a,s,e);return G.clearBuffer(),i}function Zs(a,t,s,e,i=null){const{float32Array:n,uint16Array:o,uint32Array:r}=G;let c=a*2;if(i===null&&(s.boundingBox||s.computeBoundingBox(),we.set(s.boundingBox.min,s.boundingBox.max,e),i=we),Z(c,o)){const l=t.geometry,b=l.index,h=l.attributes.position,u=s.index,_=s.attributes.position,w=J(a,r),y=tt(c,o);if(Jt.copy(e).invert(),s.boundsTree)return R(a,n,ms),ms.matrix.copy(Jt),ms.needsUpdate=!0,s.boundsTree.shapecast({intersectsBounds:p=>ms.intersectsBox(p),intersectsTriangle:p=>{p.a.applyMatrix4(e),p.b.applyMatrix4(e),p.c.applyMatrix4(e),p.needsUpdate=!0;for(let I=w,m=y+w;I<m;I++)if(k(Nt,3*t.resolveTriangleIndex(I),b,h),Nt.needsUpdate=!0,p.intersectsTriangle(Nt))return!0;return!1}});for(let d=w,p=y+w;d<p;d++){const I=t.resolveTriangleIndex(d);k(Rt,3*I,b,h),Rt.a.applyMatrix4(Jt),Rt.b.applyMatrix4(Jt),Rt.c.applyMatrix4(Jt),Rt.needsUpdate=!0;for(let m=0,g=u.count;m<g;m+=3)if(k(Nt,m,u,_),Nt.needsUpdate=!0,Rt.intersectsTriangle(Nt))return!0}}else{const l=a+8,b=r[a+6];return R(l,n,ps),!!(i.intersectsBox(ps)&&Zs(l,t,s,e,i)||(R(b,n,ps),i.intersectsBox(ps)&&Zs(b,t,s,e,i)))}}const ys=new V.Matrix4,Ds=new H,Wt=new H,Li=new V.Vector3,Di=new V.Vector3,Ui=new V.Vector3,zi=new V.Vector3;function Ei(a,t,s,e={},i={},n=0,o=1/0){t.boundingBox||t.computeBoundingBox(),Ds.set(t.boundingBox.min,t.boundingBox.max,s),Ds.needsUpdate=!0;const r=a.geometry,c=r.attributes.position,f=r.index,l=t.attributes.position,b=t.index,h=Q.getPrimitive(),u=Q.getPrimitive();let _=Li,w=Di,y=null,d=null;i&&(y=Ui,d=zi);let p=1/0,I=null,m=null;return ys.copy(s).invert(),Wt.matrix.copy(ys),a.shapecast({boundsTraverseOrder:g=>Ds.distanceToBox(g),intersectsBounds:(g,A,C)=>C<p&&C<o?(A&&(Wt.min.copy(g.min),Wt.max.copy(g.max),Wt.needsUpdate=!0),!0):!1,intersectsRange:(g,A)=>{if(t.boundsTree){const C=t.boundsTree;return C.shapecast({boundsTraverseOrder:x=>Wt.distanceToBox(x),intersectsBounds:(x,M,v)=>v<p&&v<o,intersectsRange:(x,M)=>{for(let v=x,S=x+M;v<S;v++){const F=C.resolveTriangleIndex(v);k(u,3*F,b,l),u.a.applyMatrix4(s),u.b.applyMatrix4(s),u.c.applyMatrix4(s),u.needsUpdate=!0;for(let P=g,T=g+A;P<T;P++){const O=a.resolveTriangleIndex(P);k(h,3*O,f,c),h.needsUpdate=!0;const D=h.distanceToTriangle(u,_,y);if(D<p&&(w.copy(_),d&&d.copy(y),p=D,I=P,m=v),D<n)return!0}}}})}else{const C=Kt(t);for(let x=0,M=C;x<M;x++){k(u,3*x,b,l),u.a.applyMatrix4(s),u.b.applyMatrix4(s),u.c.applyMatrix4(s),u.needsUpdate=!0;for(let v=g,S=g+A;v<S;v++){const F=a.resolveTriangleIndex(v);k(h,3*F,f,c),h.needsUpdate=!0;const P=h.distanceToTriangle(u,_,y);if(P<p&&(w.copy(_),d&&d.copy(y),p=P,I=v,m=x),P<n)return!0}}}}}),Q.releasePrimitive(h),Q.releasePrimitive(u),p===1/0?null:(e.point?e.point.copy(w):e.point=w.clone(),e.distance=p,e.faceIndex=I,i&&(i.point?i.point.copy(d):i.point=d.clone(),i.point.applyMatrix4(ys),w.applyMatrix4(ys),i.distance=w.sub(i.point).length(),i.faceIndex=m),e)}function Gi(){return typeof SharedArrayBuffer<"u"}const Qt=new G.constructor,vs=new G.constructor,yt=new ee(()=>new V.Box3),kt=new V.Box3,qt=new V.Box3,Us=new V.Box3,zs=new V.Box3;let Es=!1;function Ri(a,t,s,e){if(Es)throw new Error("MeshBVH: Recursive calls to bvhcast not supported.");Es=!0;const i=a._roots,n=t._roots;let o,r=0,c=0;const f=new V.Matrix4().copy(s).invert();for(let l=0,b=i.length;l<b;l++){Qt.setBuffer(i[l]),c=0;const h=yt.getPrimitive();R(0,Qt.float32Array,h),h.applyMatrix4(f);for(let u=0,_=n.length;u<_&&(vs.setBuffer(n[l]),o=it(0,0,s,f,e,r,c,0,0,h),vs.clearBuffer(),c+=n[u].length,!o);u++);if(yt.releasePrimitive(h),Qt.clearBuffer(),r+=i[l].length,o)break}return Es=!1,o}function it(a,t,s,e,i,n=0,o=0,r=0,c=0,f=null,l=!1){let b,h;l?(b=vs,h=Qt):(b=Qt,h=vs);const u=b.float32Array,_=b.uint32Array,w=b.uint16Array,y=h.float32Array,d=h.uint32Array,p=h.uint16Array,I=a*2,m=t*2,g=Z(I,w),A=Z(m,p);let C=!1;if(A&&g)l?C=i(J(t,d),tt(t*2,p),J(a,_),tt(a*2,w),c,o+t,r,n+a):C=i(J(a,_),tt(a*2,w),J(t,d),tt(t*2,p),r,n+a,c,o+t);else if(A){const x=yt.getPrimitive();R(t,y,x),x.applyMatrix4(s);const M=st(a),v=et(a,_);R(M,u,kt),R(v,u,qt);const S=x.intersectsBox(kt),F=x.intersectsBox(qt);C=S&&it(t,M,e,s,i,o,n,c,r+1,x,!l)||F&&it(t,v,e,s,i,o,n,c,r+1,x,!l),yt.releasePrimitive(x)}else{const x=st(t),M=et(t,d);R(x,y,Us),R(M,y,zs);const v=f.intersectsBox(Us),S=f.intersectsBox(zs);if(v&&S)C=it(a,x,s,e,i,n,o,r,c+1,f,l)||it(a,M,s,e,i,n,o,r,c+1,f,l);else if(v)if(g)C=it(a,x,s,e,i,n,o,r,c+1,f,l);else{const F=yt.getPrimitive();F.copy(Us).applyMatrix4(s);const P=st(a),T=et(a,_);R(P,u,kt),R(T,u,qt);const O=F.intersectsBox(kt),D=F.intersectsBox(qt);C=O&&it(x,P,e,s,i,o,n,c,r+1,F,!l)||D&&it(x,T,e,s,i,o,n,c,r+1,F,!l),yt.releasePrimitive(F)}else if(S)if(g)C=it(a,M,s,e,i,n,o,r,c+1,f,l);else{const F=yt.getPrimitive();F.copy(zs).applyMatrix4(s);const P=st(a),T=et(a,_);R(P,u,kt),R(T,u,qt);const O=F.intersectsBox(kt),D=F.intersectsBox(qt);C=O&&it(M,P,e,s,i,o,n,c,r+1,F,!l)||D&&it(M,T,e,s,i,o,n,c,r+1,F,!l),yt.releasePrimitive(F)}}return C}const gs=new H,xe=new V.Box3;class ie{static serialize(t,s={}){s={cloneBuffers:!0,...s};const e=t.geometry,i=t._roots,n=t._indirectBuffer,o=e.getIndex();let r;return s.cloneBuffers?r={roots:i.map(c=>c.slice()),index:o.array.slice(),indirectBuffer:n?n.slice():null}:r={roots:i,index:o.array,indirectBuffer:n},r}static deserialize(t,s,e={}){e={setIndex:!0,indirect:!!t.indirectBuffer,...e};const{index:i,roots:n,indirectBuffer:o}=t,r=new ie(s,{...e,[Ss]:!0});if(r._roots=n,r._indirectBuffer=o||null,e.setIndex){const c=s.getIndex();if(c===null){const f=new V.BufferAttribute(t.index,1,!1);s.setIndex(f)}else c.array!==i&&(c.array.set(i),c.needsUpdate=!0)}return r}get indirect(){return!!this._indirectBuffer}constructor(t,s={}){if(t.isBufferGeometry){if(t.index&&t.index.isInterleavedBufferAttribute)throw new Error("MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.")}else throw new Error("MeshBVH: Only BufferGeometries are supported.");if(s=Object.assign({strategy:Ce,maxDepth:40,maxLeafTris:10,verbose:!0,useSharedArrayBuffer:!1,setBoundingBox:!0,onProgress:null,indirect:!1,[Ss]:!1},s),s.useSharedArrayBuffer&&!Gi())throw new Error("MeshBVH: SharedArrayBuffer is not available.");this.geometry=t,this._roots=null,this._indirectBuffer=null,s[Ss]||(ii(this,s),!t.boundingBox&&s.setBoundingBox&&(t.boundingBox=this.getBoundingBox(new V.Box3)));const{_indirectBuffer:e}=this;this.resolveTriangleIndex=s.indirect?i=>e[i]:i=>i}refit(t=null){return(this.indirect?Pi:pi)(this,t)}traverse(t,s=0){const e=this._roots[s],i=new Uint32Array(e),n=new Uint16Array(e);o(0);function o(r,c=0){const f=r*2,l=n[f+15]===Fs;if(l){const b=i[r+6],h=n[f+14];t(c,l,new Float32Array(e,r*4,6),b,h)}else{const b=r+ws/4,h=i[r+6],u=i[r+7];t(c,l,new Float32Array(e,r*4,6),u)||(o(b,c+1),o(h,c+1))}}}raycast(t,s=V.FrontSide){const e=this._roots,i=this.geometry,n=[],o=s.isMaterial,r=Array.isArray(s),c=i.groups,f=o?s.side:s,l=this.indirect?Si:Ii;for(let b=0,h=e.length;b<h;b++){const u=r?s[c[b].materialIndex].side:f,_=n.length;if(l(this,b,u,t,n),r){const w=c[b].materialIndex;for(let y=_,d=n.length;y<d;y++)n[y].face.materialIndex=w}}return n}raycastFirst(t,s=V.FrontSide){const e=this._roots,i=this.geometry,n=s.isMaterial,o=Array.isArray(s);let r=null;const c=i.groups,f=n?s.side:s,l=this.indirect?Ti:xi;for(let b=0,h=e.length;b<h;b++){const u=o?s[c[b].materialIndex].side:f,_=l(this,b,u,t);_!=null&&(r==null||_.distance<r.distance)&&(r=_,o&&(_.face.materialIndex=c[b].materialIndex))}return r}intersectsGeometry(t,s){let e=!1;const i=this._roots,n=this.indirect?Oi:Ai;for(let o=0,r=i.length;o<r&&(e=n(this,o,t,s),!e);o++);return e}shapecast(t){const s=Q.getPrimitive(),e=this.indirect?gi:_i;let{boundsTraverseOrder:i,intersectsBounds:n,intersectsRange:o,intersectsTriangle:r}=t;if(o&&r){const b=o;o=(h,u,_,w,y)=>b(h,u,_,w,y)?!0:e(h,u,this,r,_,w,s)}else o||(r?o=(b,h,u,_)=>e(b,h,this,r,u,_,s):o=(b,h,u)=>u);let c=!1,f=0;const l=this._roots;for(let b=0,h=l.length;b<h;b++){const u=l[b];if(c=fi(this,b,n,o,i,f),c)break;f+=u.byteLength}return Q.releasePrimitive(s),c}bvhcast(t,s,e){let{intersectsRanges:i,intersectsTriangles:n}=e;const o=Q.getPrimitive(),r=this.geometry.index,c=this.geometry.attributes.position,f=this.indirect?_=>{const w=this.resolveTriangleIndex(_);k(o,w*3,r,c)}:_=>{k(o,_*3,r,c)},l=Q.getPrimitive(),b=t.geometry.index,h=t.geometry.attributes.position,u=t.indirect?_=>{const w=t.resolveTriangleIndex(_);k(l,w*3,b,h)}:_=>{k(l,_*3,b,h)};if(n){const _=(w,y,d,p,I,m,g,A)=>{for(let C=d,x=d+p;C<x;C++){u(C),l.a.applyMatrix4(s),l.b.applyMatrix4(s),l.c.applyMatrix4(s),l.needsUpdate=!0;for(let M=w,v=w+y;M<v;M++)if(f(M),o.needsUpdate=!0,n(o,l,M,C,I,m,g,A))return!0}return!1};if(i){const w=i;i=function(y,d,p,I,m,g,A,C){return w(y,d,p,I,m,g,A,C)?!0:_(y,d,p,I,m,g,A,C)}}else i=_}return Ri(this,t,s,i)}intersectsBox(t,s){return gs.set(t.min,t.max,s),gs.needsUpdate=!0,this.shapecast({intersectsBounds:e=>gs.intersectsBox(e),intersectsTriangle:e=>gs.intersectsTriangle(e)})}intersectsSphere(t){return this.shapecast({intersectsBounds:s=>t.intersectsBox(s),intersectsTriangle:s=>s.intersectsSphere(t)})}closestPointToGeometry(t,s,e={},i={},n=0,o=1/0){return(this.indirect?Ei:Mi)(this,t,s,e,i,n,o)}closestPointToPoint(t,s={},e=0,i=1/0){return li(this,t,s,e,i)}getBoundingBox(t){return t.makeEmpty(),this._roots.forEach(e=>{R(0,new Float32Array(e),xe),t.union(xe)}),t}}function Ae(a,t,s){return a===null||(a.point.applyMatrix4(t.matrixWorld),a.distance=a.point.distanceTo(s.ray.origin),a.object=t,a.distance<s.near||a.distance>s.far)?null:a}const Gs=new V.Ray,ve=new V.Matrix4,Ni=V.Mesh.prototype.raycast;function ki(a,t){if(this.geometry.boundsTree){if(this.material===void 0)return;ve.copy(this.matrixWorld).invert(),Gs.copy(a.ray).applyMatrix4(ve);const s=this.geometry.boundsTree;if(a.firstHitOnly===!0){const e=Ae(s.raycastFirst(Gs,this.material),this,a);e&&t.push(e)}else{const e=s.raycast(Gs,this.material);for(let i=0,n=e.length;i<n;i++){const o=Ae(e[i],this,a);o&&t.push(o)}}}else Ni.call(this,a,t)}function qi(a){return this.boundsTree=new ie(this,a),this.boundsTree}function ji(){this.boundsTree=null}const ts=class ts{static apply(t){ts.initialized||(V.BufferGeometry.prototype.computeBoundsTree=qi,V.BufferGeometry.prototype.disposeBoundsTree=ji,V.Mesh.prototype.raycast=ki,ts.initialized=!0),t.boundsTree||t.computeBoundsTree()}static dispose(t){t&&t.disposeBoundsTree&&t.disposeBoundsTree()}};B(ts,"initialized",!1);let Vs=ts,ne=class Be{constructor(t,s,e){B(this,"ids",new Set);B(this,"itemToInstances",new Map);B(this,"instanceToItem",new Map);B(this,"hiddenItems",new Set);B(this,"id");B(this,"mesh");B(this,"capacity",0);B(this,"capacityOffset",10);B(this,"group");B(this,"_originalColors",new Map);B(this,"_settingVisibility",!1);this.mesh=new qs(t,s,e,this),this.id=this.mesh.uuid,this.capacity=e,this.mesh.count=0,this.mesh.geometry.index.count&&Vs.apply(this.mesh.geometry)}get uniqueVertices(){const t=[],s=this.mesh.geometry.getAttribute("position");if(!s)return t;const e=new Set;for(let i=0;i<s.count;i++){const n=s.getX(i),o=s.getY(i),r=s.getZ(i),c=`${n},${o},${r}`;e.has(c)||(e.add(c),t.push(new L.Vector3(n,o,r)))}return t}dispose(t=!0){if(this.clear(),this.group=void 0,this._originalColors.clear(),this.mesh){if(t){for(const s of this.mesh.material)s.dispose();this.mesh.material=[],Vs.dispose(this.mesh.geometry),this.mesh.geometry&&this.mesh.geometry.dispose(),this.mesh.geometry=null}this.mesh.removeFromParent(),this.mesh.userData={},this.mesh.dispose(),this.mesh.fragment=null,this.mesh=null}}get(t){const s=this.getInstancesIDs(t);if(!s)throw new Error("Item not found!");const e=[],i=[];for(const o of s){const r=new L.Matrix4;if(this.mesh.getMatrixAt(o,r),e.push(r),this.mesh.instanceColor){const c=new L.Color;this.mesh.getColorAt(o,c),i.push(c)}}const n=i.length?i:void 0;return{id:t,transforms:e,colors:n}}getItemID(t){return this.instanceToItem.get(t)||null}getInstancesIDs(t){return this.itemToInstances.get(t)||null}update(){this.mesh.instanceColor&&(this.mesh.instanceColor.needsUpdate=!0),this.mesh.instanceMatrix.needsUpdate=!0}add(t){var i;let s=0;for(const n of t)s+=n.transforms.length;const e=this.mesh.count+s;if(e>this.capacity){const n=e+this.capacityOffset,o=new qs(this.mesh.geometry,this.mesh.material,n,this);o.count=this.mesh.count,this.capacity=n;const r=this.mesh;(i=r.parent)==null||i.add(o),r.removeFromParent(),this.mesh=o;const c=new L.Matrix4;for(let f=0;f<r.instanceMatrix.count;f++)r.getMatrixAt(f,c),o.setMatrixAt(f,c);if(r.instanceColor){const f=new L.Color;for(let l=0;l<r.instanceColor.count;l++)r.getColorAt(l,f),o.setColorAt(l,f)}r.dispose()}for(let n=0;n<t.length;n++){const{transforms:o,colors:r,id:c}=t[n];this.itemToInstances.has(c)||this.itemToInstances.set(c,new Set);const f=this.itemToInstances.get(c);this.ids.add(c);for(let l=0;l<o.length;l++){const b=o[l],h=this.mesh.count;if(this.mesh.setMatrixAt(h,b),r){const u=r[l];this.mesh.setColorAt(h,u)}f.add(h),this.instanceToItem.set(h,c),this.mesh.count++}}this.update()}remove(t){if(this.mesh.count!==0){for(const s of t){const e=this.itemToInstances.get(s);if(e===void 0)throw new Error("Instances not found!");for(const i of e){if(this.mesh.count===0)throw new Error("Error with mesh count!");this.putLast(i),this.instanceToItem.delete(i),this.mesh.count--}this.itemToInstances.delete(s),this.ids.delete(s)}this.update()}}clear(){this.hiddenItems.clear(),this.ids.clear(),this.instanceToItem.clear(),this.itemToInstances.clear(),this.mesh.count=0}setVisibility(t,s=this.ids){if(!this._settingVisibility){if(this._settingVisibility=!0,t)for(const e of s){if(!this.ids.has(e)||!this.hiddenItems.has(e))continue;const i=this.itemToInstances.get(e);if(!i)throw new Error("Instances not found!");for(const n of new Set(i))this.mesh.count++,this.putLast(n);this.hiddenItems.delete(e)}else for(const e of s){if(!this.ids.has(e)||this.hiddenItems.has(e))continue;const i=this.itemToInstances.get(e);if(!i)throw new Error("Instances not found!");for(const n of new Set(i))this.putLast(n),this.mesh.count--;this.hiddenItems.add(e)}this.update(),this._settingVisibility=!1}}setColor(t,s=this.ids,e=!1){if(!this.mesh.instanceColor)throw new Error("This fragment doesn't have color per instance!");for(const i of s){if(!this.ids.has(i))continue;const n=this.itemToInstances.get(i);if(!n)throw new Error("Instances not found!");const o=this._originalColors.has(i);o||this._originalColors.set(i,new Map);const r=this._originalColors.get(i);for(const c of new Set(n)){if(!o){const f=new L.Color;this.mesh.getColorAt(c,f),r.set(c,f)}this.mesh.setColorAt(c,t),e&&r.set(c,t)}}this.mesh.instanceColor.needsUpdate=!0}resetColor(t=this.ids){if(!this.mesh.instanceColor)throw new Error("This fragment doesn't have color per instance!");for(const s of t){if(!this.ids.has(s))continue;const e=this.itemToInstances.get(s);if(!e)throw new Error("Instances not found!");const i=this._originalColors.get(s);if(i)for(const n of new Set(e)){const o=i.get(n);if(!o)throw new Error("Original color not found!");this.mesh.setColorAt(n,o)}}this.mesh.instanceColor.needsUpdate=!0}applyTransform(t,s){const e=new L.Matrix4;for(const i of t){const n=this.getInstancesIDs(i);if(n!==null)for(const o of n)this.mesh.getMatrixAt(o,e),e.premultiply(s),this.mesh.setMatrixAt(o,e)}this.update()}exportData(){const t=this.mesh.exportData(),s=Array.from(this.ids),e=this.id;return{...t,ids:s,id:e}}clone(t=this.ids){const s=new Be(this.mesh.geometry,this.mesh.material,this.capacity),e=[];for(const i of t){const n=this.getInstancesIDs(i);if(n===null)continue;const o=[],r=[];for(const c of n){const f=new L.Matrix4,l=new L.Color;this.mesh.getMatrixAt(c,f),this.mesh.getColorAt(c,l),o.push(f),r.push(l)}e.push({id:i,transforms:o,colors:r})}return s.add(e),s}putLast(t){if(this.mesh.count===0)return;const s=this.instanceToItem.get(t),e=this.mesh.count-1;if(e===t)return;const i=this.instanceToItem.get(e);if(s===void 0||i===void 0)throw new Error("Keys not found");if(s!==i){const r=this.itemToInstances.get(s),c=this.itemToInstances.get(i);if(!r||!c)throw new Error("Instances not found");if(!r.has(t)||!c.has(e))throw new Error("Malformed fragment structure");r.delete(t),c.delete(e),r.add(e),c.add(t),this.instanceToItem.set(t,i),this.instanceToItem.set(e,s)}const n=new L.Matrix4,o=new L.Matrix4;if(this.mesh.getMatrixAt(t,n),this.mesh.getMatrixAt(e,o),this.mesh.setMatrixAt(t,o),this.mesh.setMatrixAt(e,n),this.mesh.instanceColor!==null){const r=new L.Color,c=new L.Color;this.mesh.getColorAt(t,r),this.mesh.getColorAt(e,c),this.mesh.setColorAt(t,c),this.mesh.setColorAt(e,r);const f=this._originalColors.get(s);if(f){const b=f.get(t);b&&(f.delete(t),f.set(e,b))}const l=this._originalColors.get(i);if(l){const b=l.get(e);b&&(l.delete(e),l.set(t,b))}}}};const Rs=2,ct=4,bt=4,W=4,gt=new Int32Array(2),Ve=new Float32Array(gt.buffer),Fe=new Float64Array(gt.buffer),Is=new Uint16Array(new Uint8Array([1,0]).buffer)[0]===1;var Js;(function(a){a[a.UTF8_BYTES=1]="UTF8_BYTES",a[a.UTF16_STRING=2]="UTF16_STRING"})(Js||(Js={}));class Tt{constructor(t){this.bytes_=t,this.position_=0,this.text_decoder_=new TextDecoder}static allocate(t){return new Tt(new Uint8Array(t))}clear(){this.position_=0}bytes(){return this.bytes_}position(){return this.position_}setPosition(t){this.position_=t}capacity(){return this.bytes_.length}readInt8(t){return this.readUint8(t)<<24>>24}readUint8(t){return this.bytes_[t]}readInt16(t){return this.readUint16(t)<<16>>16}readUint16(t){return this.bytes_[t]|this.bytes_[t+1]<<8}readInt32(t){return this.bytes_[t]|this.bytes_[t+1]<<8|this.bytes_[t+2]<<16|this.bytes_[t+3]<<24}readUint32(t){return this.readInt32(t)>>>0}readInt64(t){return BigInt.asIntN(64,BigInt(this.readUint32(t))+(BigInt(this.readUint32(t+4))<<BigInt(32)))}readUint64(t){return BigInt.asUintN(64,BigInt(this.readUint32(t))+(BigInt(this.readUint32(t+4))<<BigInt(32)))}readFloat32(t){return gt[0]=this.readInt32(t),Ve[0]}readFloat64(t){return gt[Is?0:1]=this.readInt32(t),gt[Is?1:0]=this.readInt32(t+4),Fe[0]}writeInt8(t,s){this.bytes_[t]=s}writeUint8(t,s){this.bytes_[t]=s}writeInt16(t,s){this.bytes_[t]=s,this.bytes_[t+1]=s>>8}writeUint16(t,s){this.bytes_[t]=s,this.bytes_[t+1]=s>>8}writeInt32(t,s){this.bytes_[t]=s,this.bytes_[t+1]=s>>8,this.bytes_[t+2]=s>>16,this.bytes_[t+3]=s>>24}writeUint32(t,s){this.bytes_[t]=s,this.bytes_[t+1]=s>>8,this.bytes_[t+2]=s>>16,this.bytes_[t+3]=s>>24}writeInt64(t,s){this.writeInt32(t,Number(BigInt.asIntN(32,s))),this.writeInt32(t+4,Number(BigInt.asIntN(32,s>>BigInt(32))))}writeUint64(t,s){this.writeUint32(t,Number(BigInt.asUintN(32,s))),this.writeUint32(t+4,Number(BigInt.asUintN(32,s>>BigInt(32))))}writeFloat32(t,s){Ve[0]=s,this.writeInt32(t,gt[0])}writeFloat64(t,s){Fe[0]=s,this.writeInt32(t,gt[Is?0:1]),this.writeInt32(t+4,gt[Is?1:0])}getBufferIdentifier(){if(this.bytes_.length<this.position_+ct+bt)throw new Error("FlatBuffers: ByteBuffer is too short to contain an identifier.");let t="";for(let s=0;s<bt;s++)t+=String.fromCharCode(this.readInt8(this.position_+ct+s));return t}__offset(t,s){const e=t-this.readInt32(t);return s<this.readInt16(e)?this.readInt16(e+s):0}__union(t,s){return t.bb_pos=s+this.readInt32(s),t.bb=this,t}__string(t,s){t+=this.readInt32(t);const e=this.readInt32(t);t+=ct;const i=this.bytes_.subarray(t,t+e);return s===Js.UTF8_BYTES?i:this.text_decoder_.decode(i)}__union_with_string(t,s){return typeof t=="string"?this.__string(s):this.__union(t,s)}__indirect(t){return t+this.readInt32(t)}__vector(t){return t+this.readInt32(t)+ct}__vector_len(t){return this.readInt32(t+this.readInt32(t))}__has_identifier(t){if(t.length!=bt)throw new Error("FlatBuffers: file identifier must be length "+bt);for(let s=0;s<bt;s++)if(t.charCodeAt(s)!=this.readInt8(this.position()+ct+s))return!1;return!0}createScalarList(t,s){const e=[];for(let i=0;i<s;++i){const n=t(i);n!==null&&e.push(n)}return e}createObjList(t,s){const e=[];for(let i=0;i<s;++i){const n=t(i);n!==null&&e.push(n.unpack())}return e}}class is{constructor(t){this.minalign=1,this.vtable=null,this.vtable_in_use=0,this.isNested=!1,this.object_start=0,this.vtables=[],this.vector_num_elems=0,this.force_defaults=!1,this.string_maps=null,this.text_encoder=new TextEncoder;let s;t?s=t:s=1024,this.bb=Tt.allocate(s),this.space=s}clear(){this.bb.clear(),this.space=this.bb.capacity(),this.minalign=1,this.vtable=null,this.vtable_in_use=0,this.isNested=!1,this.object_start=0,this.vtables=[],this.vector_num_elems=0,this.force_defaults=!1,this.string_maps=null}forceDefaults(t){this.force_defaults=t}dataBuffer(){return this.bb}asUint8Array(){return this.bb.bytes().subarray(this.bb.position(),this.bb.position()+this.offset())}prep(t,s){t>this.minalign&&(this.minalign=t);const e=~(this.bb.capacity()-this.space+s)+1&t-1;for(;this.space<e+t+s;){const i=this.bb.capacity();this.bb=is.growByteBuffer(this.bb),this.space+=this.bb.capacity()-i}this.pad(e)}pad(t){for(let s=0;s<t;s++)this.bb.writeInt8(--this.space,0)}writeInt8(t){this.bb.writeInt8(this.space-=1,t)}writeInt16(t){this.bb.writeInt16(this.space-=2,t)}writeInt32(t){this.bb.writeInt32(this.space-=4,t)}writeInt64(t){this.bb.writeInt64(this.space-=8,t)}writeFloat32(t){this.bb.writeFloat32(this.space-=4,t)}writeFloat64(t){this.bb.writeFloat64(this.space-=8,t)}addInt8(t){this.prep(1,0),this.writeInt8(t)}addInt16(t){this.prep(2,0),this.writeInt16(t)}addInt32(t){this.prep(4,0),this.writeInt32(t)}addInt64(t){this.prep(8,0),this.writeInt64(t)}addFloat32(t){this.prep(4,0),this.writeFloat32(t)}addFloat64(t){this.prep(8,0),this.writeFloat64(t)}addFieldInt8(t,s,e){(this.force_defaults||s!=e)&&(this.addInt8(s),this.slot(t))}addFieldInt16(t,s,e){(this.force_defaults||s!=e)&&(this.addInt16(s),this.slot(t))}addFieldInt32(t,s,e){(this.force_defaults||s!=e)&&(this.addInt32(s),this.slot(t))}addFieldInt64(t,s,e){(this.force_defaults||s!==e)&&(this.addInt64(s),this.slot(t))}addFieldFloat32(t,s,e){(this.force_defaults||s!=e)&&(this.addFloat32(s),this.slot(t))}addFieldFloat64(t,s,e){(this.force_defaults||s!=e)&&(this.addFloat64(s),this.slot(t))}addFieldOffset(t,s,e){(this.force_defaults||s!=e)&&(this.addOffset(s),this.slot(t))}addFieldStruct(t,s,e){s!=e&&(this.nested(s),this.slot(t))}nested(t){if(t!=this.offset())throw new Error("FlatBuffers: struct must be serialized inline.")}notNested(){if(this.isNested)throw new Error("FlatBuffers: object serialization must not be nested.")}slot(t){this.vtable!==null&&(this.vtable[t]=this.offset())}offset(){return this.bb.capacity()-this.space}static growByteBuffer(t){const s=t.capacity();if(s&3221225472)throw new Error("FlatBuffers: cannot grow buffer beyond 2 gigabytes.");const e=s<<1,i=Tt.allocate(e);return i.setPosition(e-s),i.bytes().set(t.bytes(),e-s),i}addOffset(t){this.prep(ct,0),this.writeInt32(this.offset()-t+ct)}startObject(t){this.notNested(),this.vtable==null&&(this.vtable=[]),this.vtable_in_use=t;for(let s=0;s<t;s++)this.vtable[s]=0;this.isNested=!0,this.object_start=this.offset()}endObject(){if(this.vtable==null||!this.isNested)throw new Error("FlatBuffers: endObject called without startObject");this.addInt32(0);const t=this.offset();let s=this.vtable_in_use-1;for(;s>=0&&this.vtable[s]==0;s--);const e=s+1;for(;s>=0;s--)this.addInt16(this.vtable[s]!=0?t-this.vtable[s]:0);const i=2;this.addInt16(t-this.object_start);const n=(e+i)*Rs;this.addInt16(n);let o=0;const r=this.space;t:for(s=0;s<this.vtables.length;s++){const c=this.bb.capacity()-this.vtables[s];if(n==this.bb.readInt16(c)){for(let f=Rs;f<n;f+=Rs)if(this.bb.readInt16(r+f)!=this.bb.readInt16(c+f))continue t;o=this.vtables[s];break}}return o?(this.space=this.bb.capacity()-t,this.bb.writeInt32(this.space,o-t)):(this.vtables.push(this.offset()),this.bb.writeInt32(this.bb.capacity()-t,this.offset()-t)),this.isNested=!1,t}finish(t,s,e){const i=e?W:0;if(s){const n=s;if(this.prep(this.minalign,ct+bt+i),n.length!=bt)throw new Error("FlatBuffers: file identifier must be length "+bt);for(let o=bt-1;o>=0;o--)this.writeInt8(n.charCodeAt(o))}this.prep(this.minalign,ct+i),this.addOffset(t),i&&this.addInt32(this.bb.capacity()-this.space),this.bb.setPosition(this.space)}finishSizePrefixed(t,s){this.finish(t,s,!0)}requiredField(t,s){const e=this.bb.capacity()-t,i=e-this.bb.readInt32(e);if(!(s<this.bb.readInt16(i)&&this.bb.readInt16(i+s)!=0))throw new Error("FlatBuffers: field "+s+" must be set")}startVector(t,s,e){this.notNested(),this.vector_num_elems=s,this.prep(ct,t*s),this.prep(e,t*s)}endVector(){return this.writeInt32(this.vector_num_elems),this.offset()}createSharedString(t){if(!t)return 0;if(this.string_maps||(this.string_maps=new Map),this.string_maps.has(t))return this.string_maps.get(t);const s=this.createString(t);return this.string_maps.set(t,s),s}createString(t){if(t==null)return 0;let s;t instanceof Uint8Array?s=t:s=this.text_encoder.encode(t),this.addInt8(0),this.startVector(1,s.length,1),this.bb.setPosition(this.space-=s.length);for(let e=0,i=this.space,n=this.bb.bytes();e<s.length;e++)n[i++]=s[e];return this.endVector()}createObjectOffset(t){return t===null?0:typeof t=="string"?this.createString(t):t.pack(this)}createObjectOffsetList(t){const s=[];for(let e=0;e<t.length;++e){const i=t[e];if(i!==null)s.push(this.createObjectOffset(i));else throw new Error("FlatBuffers: Argument for createObjectOffsetList cannot contain null.")}return s}createStructOffsetList(t,s){return s(this,t.length),this.createObjectOffsetList(t.slice().reverse()),this.endVector()}}let xs=class Pt{constructor(){B(this,"bb",null);B(this,"bb_pos",0)}__init(t,s){return this.bb_pos=t,this.bb=s,this}static getRootAsCivilCurve(t,s){return(s||new Pt).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsCivilCurve(t,s){return t.setPosition(t.position()+W),(s||new Pt).__init(t.readInt32(t.position())+t.position(),t)}points(t){const s=this.bb.__offset(this.bb_pos,4);return s?this.bb.readFloat32(this.bb.__vector(this.bb_pos+s)+t*4):0}pointsLength(){const t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__vector_len(this.bb_pos+t):0}pointsArray(){const t=this.bb.__offset(this.bb_pos,4);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}data(t){const s=this.bb.__offset(this.bb_pos,6);return s?this.bb.__string(this.bb_pos+s,t):null}static startCivilCurve(t){t.startObject(2)}static addPoints(t,s){t.addFieldOffset(0,s,0)}static createPointsVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addFloat32(s[e]);return t.endVector()}static startPointsVector(t,s){t.startVector(4,s,4)}static addData(t,s){t.addFieldOffset(1,s,0)}static endCivilCurve(t){return t.endObject()}static createCivilCurve(t,s,e){return Pt.startCivilCurve(t),Pt.addPoints(t,s),Pt.addData(t,e),Pt.endCivilCurve(t)}},Te=class ft{constructor(){B(this,"bb",null);B(this,"bb_pos",0)}__init(t,s){return this.bb_pos=t,this.bb=s,this}static getRootAsAlignment(t,s){return(s||new ft).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsAlignment(t,s){return t.setPosition(t.position()+W),(s||new ft).__init(t.readInt32(t.position())+t.position(),t)}vertical(t,s){const e=this.bb.__offset(this.bb_pos,4);return e?(s||new xs).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+e)+t*4),this.bb):null}verticalLength(){const t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__vector_len(this.bb_pos+t):0}horizontal(t,s){const e=this.bb.__offset(this.bb_pos,6);return e?(s||new xs).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+e)+t*4),this.bb):null}horizontalLength(){const t=this.bb.__offset(this.bb_pos,6);return t?this.bb.__vector_len(this.bb_pos+t):0}absolute(t,s){const e=this.bb.__offset(this.bb_pos,8);return e?(s||new xs).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+e)+t*4),this.bb):null}absoluteLength(){const t=this.bb.__offset(this.bb_pos,8);return t?this.bb.__vector_len(this.bb_pos+t):0}initialPk(){const t=this.bb.__offset(this.bb_pos,10);return t?this.bb.readFloat32(this.bb_pos+t):0}static startAlignment(t){t.startObject(4)}static addVertical(t,s){t.addFieldOffset(0,s,0)}static createVerticalVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addOffset(s[e]);return t.endVector()}static startVerticalVector(t,s){t.startVector(4,s,4)}static addHorizontal(t,s){t.addFieldOffset(1,s,0)}static createHorizontalVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addOffset(s[e]);return t.endVector()}static startHorizontalVector(t,s){t.startVector(4,s,4)}static addAbsolute(t,s){t.addFieldOffset(2,s,0)}static createAbsoluteVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addOffset(s[e]);return t.endVector()}static startAbsoluteVector(t,s){t.startVector(4,s,4)}static addInitialPk(t,s){t.addFieldFloat32(3,s,0)}static endAlignment(t){return t.endObject()}static createAlignment(t,s,e,i,n){return ft.startAlignment(t),ft.addVertical(t,s),ft.addHorizontal(t,e),ft.addAbsolute(t,i),ft.addInitialPk(t,n),ft.endAlignment(t)}},Oe=class St{constructor(){B(this,"bb",null);B(this,"bb_pos",0)}__init(t,s){return this.bb_pos=t,this.bb=s,this}static getRootAsCivilData(t,s){return(s||new St).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsCivilData(t,s){return t.setPosition(t.position()+W),(s||new St).__init(t.readInt32(t.position())+t.position(),t)}alignments(t,s){const e=this.bb.__offset(this.bb_pos,4);return e?(s||new Te).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+e)+t*4),this.bb):null}alignmentsLength(){const t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__vector_len(this.bb_pos+t):0}coordinationMatrix(t){const s=this.bb.__offset(this.bb_pos,6);return s?this.bb.readFloat32(this.bb.__vector(this.bb_pos+s)+t*4):0}coordinationMatrixLength(){const t=this.bb.__offset(this.bb_pos,6);return t?this.bb.__vector_len(this.bb_pos+t):0}coordinationMatrixArray(){const t=this.bb.__offset(this.bb_pos,6);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}static startCivilData(t){t.startObject(2)}static addAlignments(t,s){t.addFieldOffset(0,s,0)}static createAlignmentsVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addOffset(s[e]);return t.endVector()}static startAlignmentsVector(t,s){t.startVector(4,s,4)}static addCoordinationMatrix(t,s){t.addFieldOffset(1,s,0)}static createCoordinationMatrixVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addFloat32(s[e]);return t.endVector()}static startCoordinationMatrixVector(t,s){t.startVector(4,s,4)}static endCivilData(t){return t.endObject()}static createCivilData(t,s,e){return St.startCivilData(t),St.addAlignments(t,s),St.addCoordinationMatrix(t,e),St.endCivilData(t)}},Ws=class j{constructor(){B(this,"bb",null);B(this,"bb_pos",0)}__init(t,s){return this.bb_pos=t,this.bb=s,this}static getRootAsFragment(t,s){return(s||new j).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsFragment(t,s){return t.setPosition(t.position()+W),(s||new j).__init(t.readInt32(t.position())+t.position(),t)}position(t){const s=this.bb.__offset(this.bb_pos,4);return s?this.bb.readFloat32(this.bb.__vector(this.bb_pos+s)+t*4):0}positionLength(){const t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__vector_len(this.bb_pos+t):0}positionArray(){const t=this.bb.__offset(this.bb_pos,4);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}normal(t){const s=this.bb.__offset(this.bb_pos,6);return s?this.bb.readFloat32(this.bb.__vector(this.bb_pos+s)+t*4):0}normalLength(){const t=this.bb.__offset(this.bb_pos,6);return t?this.bb.__vector_len(this.bb_pos+t):0}normalArray(){const t=this.bb.__offset(this.bb_pos,6);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}index(t){const s=this.bb.__offset(this.bb_pos,8);return s?this.bb.readUint32(this.bb.__vector(this.bb_pos+s)+t*4):0}indexLength(){const t=this.bb.__offset(this.bb_pos,8);return t?this.bb.__vector_len(this.bb_pos+t):0}indexArray(){const t=this.bb.__offset(this.bb_pos,8);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}groups(t){const s=this.bb.__offset(this.bb_pos,10);return s?this.bb.readFloat32(this.bb.__vector(this.bb_pos+s)+t*4):0}groupsLength(){const t=this.bb.__offset(this.bb_pos,10);return t?this.bb.__vector_len(this.bb_pos+t):0}groupsArray(){const t=this.bb.__offset(this.bb_pos,10);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}materials(t){const s=this.bb.__offset(this.bb_pos,12);return s?this.bb.readFloat32(this.bb.__vector(this.bb_pos+s)+t*4):0}materialsLength(){const t=this.bb.__offset(this.bb_pos,12);return t?this.bb.__vector_len(this.bb_pos+t):0}materialsArray(){const t=this.bb.__offset(this.bb_pos,12);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}matrices(t){const s=this.bb.__offset(this.bb_pos,14);return s?this.bb.readFloat32(this.bb.__vector(this.bb_pos+s)+t*4):0}matricesLength(){const t=this.bb.__offset(this.bb_pos,14);return t?this.bb.__vector_len(this.bb_pos+t):0}matricesArray(){const t=this.bb.__offset(this.bb_pos,14);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}colors(t){const s=this.bb.__offset(this.bb_pos,16);return s?this.bb.readFloat32(this.bb.__vector(this.bb_pos+s)+t*4):0}colorsLength(){const t=this.bb.__offset(this.bb_pos,16);return t?this.bb.__vector_len(this.bb_pos+t):0}colorsArray(){const t=this.bb.__offset(this.bb_pos,16);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}itemsSize(t){const s=this.bb.__offset(this.bb_pos,18);return s?this.bb.readUint32(this.bb.__vector(this.bb_pos+s)+t*4):0}itemsSizeLength(){const t=this.bb.__offset(this.bb_pos,18);return t?this.bb.__vector_len(this.bb_pos+t):0}itemsSizeArray(){const t=this.bb.__offset(this.bb_pos,18);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}ids(t){const s=this.bb.__offset(this.bb_pos,20);return s?this.bb.readUint32(this.bb.__vector(this.bb_pos+s)+t*4):0}idsLength(){const t=this.bb.__offset(this.bb_pos,20);return t?this.bb.__vector_len(this.bb_pos+t):0}idsArray(){const t=this.bb.__offset(this.bb_pos,20);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}id(t){const s=this.bb.__offset(this.bb_pos,22);return s?this.bb.__string(this.bb_pos+s,t):null}capacity(){const t=this.bb.__offset(this.bb_pos,24);return t?this.bb.readUint32(this.bb_pos+t):0}capacityOffset(){const t=this.bb.__offset(this.bb_pos,26);return t?this.bb.readUint32(this.bb_pos+t):0}static startFragment(t){t.startObject(12)}static addPosition(t,s){t.addFieldOffset(0,s,0)}static createPositionVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addFloat32(s[e]);return t.endVector()}static startPositionVector(t,s){t.startVector(4,s,4)}static addNormal(t,s){t.addFieldOffset(1,s,0)}static createNormalVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addFloat32(s[e]);return t.endVector()}static startNormalVector(t,s){t.startVector(4,s,4)}static addIndex(t,s){t.addFieldOffset(2,s,0)}static createIndexVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addInt32(s[e]);return t.endVector()}static startIndexVector(t,s){t.startVector(4,s,4)}static addGroups(t,s){t.addFieldOffset(3,s,0)}static createGroupsVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addFloat32(s[e]);return t.endVector()}static startGroupsVector(t,s){t.startVector(4,s,4)}static addMaterials(t,s){t.addFieldOffset(4,s,0)}static createMaterialsVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addFloat32(s[e]);return t.endVector()}static startMaterialsVector(t,s){t.startVector(4,s,4)}static addMatrices(t,s){t.addFieldOffset(5,s,0)}static createMatricesVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addFloat32(s[e]);return t.endVector()}static startMatricesVector(t,s){t.startVector(4,s,4)}static addColors(t,s){t.addFieldOffset(6,s,0)}static createColorsVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addFloat32(s[e]);return t.endVector()}static startColorsVector(t,s){t.startVector(4,s,4)}static addItemsSize(t,s){t.addFieldOffset(7,s,0)}static createItemsSizeVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addInt32(s[e]);return t.endVector()}static startItemsSizeVector(t,s){t.startVector(4,s,4)}static addIds(t,s){t.addFieldOffset(8,s,0)}static createIdsVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addInt32(s[e]);return t.endVector()}static startIdsVector(t,s){t.startVector(4,s,4)}static addId(t,s){t.addFieldOffset(9,s,0)}static addCapacity(t,s){t.addFieldInt32(10,s,0)}static addCapacityOffset(t,s){t.addFieldInt32(11,s,0)}static endFragment(t){return t.endObject()}static createFragment(t,s,e,i,n,o,r,c,f,l,b,h,u){return j.startFragment(t),j.addPosition(t,s),j.addNormal(t,e),j.addIndex(t,i),j.addGroups(t,n),j.addMaterials(t,o),j.addMatrices(t,r),j.addColors(t,c),j.addItemsSize(t,f),j.addIds(t,l),j.addId(t,b),j.addCapacity(t,h),j.addCapacityOffset(t,u),j.endFragment(t)}},Ns=class Qs{constructor(){B(this,"bb",null);B(this,"bb_pos",0)}__init(t,s){return this.bb_pos=t,this.bb=s,this}static getRootAsFragmentsGroup(t,s){return(s||new Qs).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsFragmentsGroup(t,s){return t.setPosition(t.position()+W),(s||new Qs).__init(t.readInt32(t.position())+t.position(),t)}items(t,s){const e=this.bb.__offset(this.bb_pos,4);return e?(s||new Ws).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+e)+t*4),this.bb):null}itemsLength(){const t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__vector_len(this.bb_pos+t):0}civil(t){const s=this.bb.__offset(this.bb_pos,6);return s?(t||new Oe).__init(this.bb.__indirect(this.bb_pos+s),this.bb):null}coordinationMatrix(t){const s=this.bb.__offset(this.bb_pos,8);return s?this.bb.readFloat32(this.bb.__vector(this.bb_pos+s)+t*4):0}coordinationMatrixLength(){const t=this.bb.__offset(this.bb_pos,8);return t?this.bb.__vector_len(this.bb_pos+t):0}coordinationMatrixArray(){const t=this.bb.__offset(this.bb_pos,8);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}ids(t){const s=this.bb.__offset(this.bb_pos,10);return s?this.bb.readUint32(this.bb.__vector(this.bb_pos+s)+t*4):0}idsLength(){const t=this.bb.__offset(this.bb_pos,10);return t?this.bb.__vector_len(this.bb_pos+t):0}idsArray(){const t=this.bb.__offset(this.bb_pos,10);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}itemsKeys(t){const s=this.bb.__offset(this.bb_pos,12);return s?this.bb.readUint32(this.bb.__vector(this.bb_pos+s)+t*4):0}itemsKeysLength(){const t=this.bb.__offset(this.bb_pos,12);return t?this.bb.__vector_len(this.bb_pos+t):0}itemsKeysArray(){const t=this.bb.__offset(this.bb_pos,12);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}itemsKeysIndices(t){const s=this.bb.__offset(this.bb_pos,14);return s?this.bb.readUint32(this.bb.__vector(this.bb_pos+s)+t*4):0}itemsKeysIndicesLength(){const t=this.bb.__offset(this.bb_pos,14);return t?this.bb.__vector_len(this.bb_pos+t):0}itemsKeysIndicesArray(){const t=this.bb.__offset(this.bb_pos,14);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}itemsRels(t){const s=this.bb.__offset(this.bb_pos,16);return s?this.bb.readUint32(this.bb.__vector(this.bb_pos+s)+t*4):0}itemsRelsLength(){const t=this.bb.__offset(this.bb_pos,16);return t?this.bb.__vector_len(this.bb_pos+t):0}itemsRelsArray(){const t=this.bb.__offset(this.bb_pos,16);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}itemsRelsIndices(t){const s=this.bb.__offset(this.bb_pos,18);return s?this.bb.readUint32(this.bb.__vector(this.bb_pos+s)+t*4):0}itemsRelsIndicesLength(){const t=this.bb.__offset(this.bb_pos,18);return t?this.bb.__vector_len(this.bb_pos+t):0}itemsRelsIndicesArray(){const t=this.bb.__offset(this.bb_pos,18);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}fragmentKeys(t){const s=this.bb.__offset(this.bb_pos,20);return s?this.bb.__string(this.bb_pos+s,t):null}id(t){const s=this.bb.__offset(this.bb_pos,22);return s?this.bb.__string(this.bb_pos+s,t):null}name(t){const s=this.bb.__offset(this.bb_pos,24);return s?this.bb.__string(this.bb_pos+s,t):null}ifcName(t){const s=this.bb.__offset(this.bb_pos,26);return s?this.bb.__string(this.bb_pos+s,t):null}ifcDescription(t){const s=this.bb.__offset(this.bb_pos,28);return s?this.bb.__string(this.bb_pos+s,t):null}ifcSchema(t){const s=this.bb.__offset(this.bb_pos,30);return s?this.bb.__string(this.bb_pos+s,t):null}maxExpressId(){const t=this.bb.__offset(this.bb_pos,32);return t?this.bb.readUint32(this.bb_pos+t):0}boundingBox(t){const s=this.bb.__offset(this.bb_pos,34);return s?this.bb.readFloat32(this.bb.__vector(this.bb_pos+s)+t*4):0}boundingBoxLength(){const t=this.bb.__offset(this.bb_pos,34);return t?this.bb.__vector_len(this.bb_pos+t):0}boundingBoxArray(){const t=this.bb.__offset(this.bb_pos,34);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}opaqueGeometriesIds(t){const s=this.bb.__offset(this.bb_pos,36);return s?this.bb.readInt32(this.bb.__vector(this.bb_pos+s)+t*4):0}opaqueGeometriesIdsLength(){const t=this.bb.__offset(this.bb_pos,36);return t?this.bb.__vector_len(this.bb_pos+t):0}opaqueGeometriesIdsArray(){const t=this.bb.__offset(this.bb_pos,36);return t?new Int32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}transparentGeometriesIds(t){const s=this.bb.__offset(this.bb_pos,38);return s?this.bb.readInt32(this.bb.__vector(this.bb_pos+s)+t*4):0}transparentGeometriesIdsLength(){const t=this.bb.__offset(this.bb_pos,38);return t?this.bb.__vector_len(this.bb_pos+t):0}transparentGeometriesIdsArray(){const t=this.bb.__offset(this.bb_pos,38);return t?new Int32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}static startFragmentsGroup(t){t.startObject(18)}static addItems(t,s){t.addFieldOffset(0,s,0)}static createItemsVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addOffset(s[e]);return t.endVector()}static startItemsVector(t,s){t.startVector(4,s,4)}static addCivil(t,s){t.addFieldOffset(1,s,0)}static addCoordinationMatrix(t,s){t.addFieldOffset(2,s,0)}static createCoordinationMatrixVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addFloat32(s[e]);return t.endVector()}static startCoordinationMatrixVector(t,s){t.startVector(4,s,4)}static addIds(t,s){t.addFieldOffset(3,s,0)}static createIdsVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addInt32(s[e]);return t.endVector()}static startIdsVector(t,s){t.startVector(4,s,4)}static addItemsKeys(t,s){t.addFieldOffset(4,s,0)}static createItemsKeysVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addInt32(s[e]);return t.endVector()}static startItemsKeysVector(t,s){t.startVector(4,s,4)}static addItemsKeysIndices(t,s){t.addFieldOffset(5,s,0)}static createItemsKeysIndicesVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addInt32(s[e]);return t.endVector()}static startItemsKeysIndicesVector(t,s){t.startVector(4,s,4)}static addItemsRels(t,s){t.addFieldOffset(6,s,0)}static createItemsRelsVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addInt32(s[e]);return t.endVector()}static startItemsRelsVector(t,s){t.startVector(4,s,4)}static addItemsRelsIndices(t,s){t.addFieldOffset(7,s,0)}static createItemsRelsIndicesVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addInt32(s[e]);return t.endVector()}static startItemsRelsIndicesVector(t,s){t.startVector(4,s,4)}static addFragmentKeys(t,s){t.addFieldOffset(8,s,0)}static addId(t,s){t.addFieldOffset(9,s,0)}static addName(t,s){t.addFieldOffset(10,s,0)}static addIfcName(t,s){t.addFieldOffset(11,s,0)}static addIfcDescription(t,s){t.addFieldOffset(12,s,0)}static addIfcSchema(t,s){t.addFieldOffset(13,s,0)}static addMaxExpressId(t,s){t.addFieldInt32(14,s,0)}static addBoundingBox(t,s){t.addFieldOffset(15,s,0)}static createBoundingBoxVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addFloat32(s[e]);return t.endVector()}static startBoundingBoxVector(t,s){t.startVector(4,s,4)}static addOpaqueGeometriesIds(t,s){t.addFieldOffset(16,s,0)}static createOpaqueGeometriesIdsVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addInt32(s[e]);return t.endVector()}static startOpaqueGeometriesIdsVector(t,s){t.startVector(4,s,4)}static addTransparentGeometriesIds(t,s){t.addFieldOffset(17,s,0)}static createTransparentGeometriesIdsVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addInt32(s[e]);return t.endVector()}static startTransparentGeometriesIdsVector(t,s){t.startVector(4,s,4)}static endFragmentsGroup(t){return t.endObject()}static finishFragmentsGroupBuffer(t,s){t.finish(s)}static finishSizePrefixedFragmentsGroupBuffer(t,s){t.finish(s,void 0,!0)}};class Ki{constructor(){B(this,"version",1);B(this,"fragmentIDSeparator","|")}import(t){const s=new Tt(t),e=Ns.getRootAsFragmentsGroup(s),i=this.constructFragmentGroup(e),n=e.itemsLength();for(let o=0;o<n;o++){const r=e.items(o);if(!r)continue;const c=this.constructGeometry(r),f=this.constructMaterials(r),l=r.capacity(),b=new ne(c,f,l);b.capacityOffset=r.capacityOffset(),this.setInstances(r,b),this.setID(r,b),i.items.push(b),i.add(b.mesh)}return i}export(t){const s=new is(1024),e=[],i=Ns,n=Ws;let o=null;if(t.civilData){const q=[],E=Te,z=Oe;for(const[rt,dt]of t.civilData.alignments){const{absolute:Ot,horizontal:_t,vertical:At}=dt,vt=this.saveCivilCurves(_t,s),Vt=this.saveCivilCurves(At,s),Ft=this.saveCivilCurves(Ot,s),Ct=E.createHorizontalVector(s,vt),Mt=E.createVerticalVector(s,Vt),pt=E.createAbsoluteVector(s,Ft);E.startAlignment(s),E.addHorizontal(s,Ct),E.addVertical(s,Mt),E.addAbsolute(s,pt),E.addInitialPk(s,dt.initialKP);const $t=E.endAlignment(s);q.push($t)}const U=z.createAlignmentsVector(s,q),K=z.createCoordinationMatrixVector(s,t.coordinationMatrix.elements);z.startCivilData(s),z.addAlignments(s,U),z.addCoordinationMatrix(s,K),o=z.endCivilData(s)}for(const q of t.items){const E=q.exportData(),z=[];for(const Mt of q.ids){const pt=q.getInstancesIDs(Mt);if(!pt)throw new Error("Instances not found!");z.push(pt.size)}const U=n.createPositionVector(s,E.position),K=n.createNormalVector(s,E.normal),rt=n.createIndexVector(s,E.index),dt=n.createGroupsVector(s,E.groups),Ot=n.createMaterialsVector(s,E.materials),_t=n.createMatricesVector(s,E.matrices),At=n.createColorsVector(s,E.colors),vt=n.createIdsVector(s,E.ids),Vt=n.createItemsSizeVector(s,z),Ft=s.createString(E.id);n.startFragment(s),n.addPosition(s,U),n.addNormal(s,K),n.addIndex(s,rt),n.addGroups(s,dt),n.addMaterials(s,Ot),n.addMatrices(s,_t),n.addColors(s,At),n.addIds(s,vt),n.addItemsSize(s,Vt),n.addId(s,Ft),n.addCapacity(s,q.capacity),n.addCapacityOffset(s,q.capacityOffset);const Ct=Ws.endFragment(s);e.push(Ct)}const r=i.createItemsVector(s,e),c=i.createCoordinationMatrixVector(s,t.coordinationMatrix.elements);let f="";for(const q of t.keyFragments.values())f.length&&(f+=this.fragmentIDSeparator),f+=q;const l=s.createString(f),b=[],h=[],u=[],_=[],w=[];let y=0,d=0;for(const[q,[E,z]]of t.data){b.push(y),u.push(d),w.push(q);for(const U of E)h.push(U);for(const U of z)_.push(U);y+=E.length,d+=z.length}const p=[],I=[];for(const[q,E]of t.geometryIDs.opaque)p.push(q,E);for(const[q,E]of t.geometryIDs.transparent)I.push(q,E);const m=s.createString(t.uuid),g=s.createString(t.name),A=s.createString(t.ifcMetadata.name),C=s.createString(t.ifcMetadata.description),x=s.createString(t.ifcMetadata.schema),M=i.createItemsKeysIndicesVector(s,b),v=i.createItemsKeysVector(s,h),S=i.createItemsRelsIndicesVector(s,u),F=i.createItemsRelsVector(s,_),P=i.createIdsVector(s,w),T=i.createOpaqueGeometriesIdsVector(s,p),O=i.createTransparentGeometriesIdsVector(s,I),{min:D,max:$}=t.boundingBox,X=[D.x,D.y,D.z,$.x,$.y,$.z],Y=i.createBoundingBoxVector(s,X);i.startFragmentsGroup(s),i.addId(s,m),i.addName(s,g),i.addIfcName(s,A),i.addIfcDescription(s,C),i.addIfcSchema(s,x),i.addMaxExpressId(s,t.ifcMetadata.maxExpressID),i.addItems(s,r),i.addFragmentKeys(s,l),i.addIds(s,P),i.addItemsKeysIndices(s,M),i.addItemsKeys(s,v),i.addItemsRelsIndices(s,S),i.addItemsRels(s,F),i.addCoordinationMatrix(s,c),i.addBoundingBox(s,Y),i.addOpaqueGeometriesIds(s,T),i.addTransparentGeometriesIds(s,O),o!==null&&i.addCivil(s,o);const Ms=Ns.endFragmentsGroup(s);return s.finish(Ms),s.asUint8Array()}setID(t,s){const e=t.id();e&&(s.id=e,s.mesh.uuid=e)}setInstances(t,s){const e=t.matricesArray(),i=t.colorsArray(),n=t.idsArray(),o=t.itemsSizeArray();if(!e||!n||!o)throw new Error("Error: Can't load empty fragment!");const r=[];let c=0;for(let f=0;f<o.length;f++){const l=n[f],b=o[f],h=[],u=[];for(let w=0;w<b;w++){const y=c*16,d=e.subarray(y,y+17),p=new L.Matrix4().fromArray(d);if(h.push(p),i){const I=c*3,[m,g,A]=i.subarray(I,I+4),C=new L.Color(m,g,A);u.push(C)}c++}const _=u.length?u:void 0;r.push({id:l,transforms:h,colors:_})}s.add(r)}constructMaterials(t){const s=t.materialsArray(),e=[];if(!s)return e;for(let i=0;i<s.length;i+=5){const n=s[i],o=!!s[i+1],r=s[i+2],c=s[i+3],f=s[i+4],l=new L.Color(r,c,f),b=new L.MeshLambertMaterial({color:l,opacity:n,transparent:o});e.push(b)}return e}constructFragmentGroup(t){const s=new es,e=t.civil();if(e){const x=e.coordinationMatrixArray(),M=new L.Matrix4;x&&M.fromArray(x),s.civilData={alignments:new Map,coordinationMatrix:M};const v=e.alignmentsLength();for(let S=0;S<v;S++){const F=new L.LineBasicMaterial({color:16777215}),P=new oe,T=e.alignments(S);if(!T)throw new Error("Alignment not found!");const O=T.horizontalLength();P.horizontal=this.constructCivilCurves(T,P,"horizontal",O,F);const D=T.verticalLength();P.vertical=this.constructCivilCurves(T,P,"vertical",D,F);const $=T.horizontalLength();P.absolute=this.constructCivilCurves(T,P,"absolute",$,F),P.initialKP=T.initialPk(),s.civilData.alignments.set(S,P)}}s.uuid=t.id()||s.uuid,s.name=t.name()||"",s.ifcMetadata={name:t.ifcName()||"",description:t.ifcDescription()||"",schema:t.ifcSchema()||"IFC2X3",maxExpressID:t.maxExpressId()||0};const i=new L.Matrix4().elements,n=t.coordinationMatrixArray()||i,o=t.idsArray()||new Uint32Array,r=t.itemsKeysIndicesArray()||new Uint32Array,c=t.itemsKeysArray()||new Uint32Array,f=t.itemsRelsArray()||new Uint32Array,l=t.itemsRelsIndicesArray()||new Uint32Array,h=(t.fragmentKeys()||"").split(this.fragmentIDSeparator);this.setGroupData(s,o,r,c,0),this.setGroupData(s,o,l,f,1);const u=t.opaqueGeometriesIdsArray()||new Uint32Array,_=t.transparentGeometriesIdsArray()||new Uint32Array,w=new Map;for(let x=0;x<u.length-1;x+=2){const M=u[x],v=u[x+1];w.set(M,v)}const y=new Map;for(let x=0;x<_.length-1;x+=2){const M=_[x],v=_[x+1];y.set(M,v)}s.geometryIDs={opaque:w,transparent:y};const d=t.boundingBoxArray()||[0,0,0,0,0,0],[p,I,m,g,A,C]=d;s.boundingBox.min.set(p,I,m),s.boundingBox.max.set(g,A,C);for(let x=0;x<h.length;x++)s.keyFragments.set(x,h[x]);return n.length===16&&s.coordinationMatrix.fromArray(n),s}setGroupData(t,s,e,i,n){for(let o=0;o<e.length;o++){const r=s[o],c=e[o],f=e[o+1]||i.length,l=[];for(let h=c;h<f;h++)l.push(i[h]);t.data.has(r)||t.data.set(r,[[],[]]);const b=t.data.get(r);b&&(b[n]=l)}}constructGeometry(t){const s=t.positionArray()||new Float32Array,e=t.normalArray()||new Float32Array,i=t.indexArray(),n=t.groupsArray();if(!i)throw new Error("Index not found!");const o=new L.BufferGeometry;if(o.setIndex(Array.from(i)),o.setAttribute("position",new L.BufferAttribute(s,3)),o.setAttribute("normal",new L.BufferAttribute(e,3)),n)for(let r=0;r<n.length;r+=3){const c=n[r],f=n[r+1],l=n[r+2];o.addGroup(c,f,l)}return o}constructCivilCurves(t,s,e,i,n){const o=[];for(let r=0;r<i;r++){const c=t[e](r);if(!c)throw new Error("Curve not found!");const f=c.pointsArray();if(f===null)throw new Error("Curve points not found!");let l={};const b=c.data();b&&(l=JSON.parse(b));const h=new L.EdgesGeometry,u=new L.BufferAttribute(f,3);h.setAttribute("position",u);const _=[];for(let y=0;y<f.length/3-1;y++)_.push(y,y+1);h.setIndex(_);const w=new re(r,l,s,h,n);o.push(w.curve)}return o}saveCivilCurves(t,s){const e=xs,i=[];for(const n of t){const r=n.mesh.geometry.attributes.position.array,c=e.createPointsVector(s,r),f=s.createString(JSON.stringify(n.data));e.startCivilCurve(s),e.addPoints(s,c),e.addData(s,f);const l=e.endCivilCurve(s);i.push(l)}return i}}let As=class Bt{constructor(){B(this,"bb",null);B(this,"bb_pos",0)}__init(t,s){return this.bb_pos=t,this.bb=s,this}static getRootAsCivilCurve(t,s){return(s||new Bt).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsCivilCurve(t,s){return t.setPosition(t.position()+W),(s||new Bt).__init(t.readInt32(t.position())+t.position(),t)}points(t){const s=this.bb.__offset(this.bb_pos,4);return s?this.bb.readFloat32(this.bb.__vector(this.bb_pos+s)+t*4):0}pointsLength(){const t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__vector_len(this.bb_pos+t):0}pointsArray(){const t=this.bb.__offset(this.bb_pos,4);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}data(t){const s=this.bb.__offset(this.bb_pos,6);return s?this.bb.__string(this.bb_pos+s,t):null}static startCivilCurve(t){t.startObject(2)}static addPoints(t,s){t.addFieldOffset(0,s,0)}static createPointsVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addFloat32(s[e]);return t.endVector()}static startPointsVector(t,s){t.startVector(4,s,4)}static addData(t,s){t.addFieldOffset(1,s,0)}static endCivilCurve(t){return t.endObject()}static createCivilCurve(t,s,e){return Bt.startCivilCurve(t),Bt.addPoints(t,s),Bt.addData(t,e),Bt.endCivilCurve(t)}},Le=class lt{constructor(){B(this,"bb",null);B(this,"bb_pos",0)}__init(t,s){return this.bb_pos=t,this.bb=s,this}static getRootAsAlignment(t,s){return(s||new lt).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsAlignment(t,s){return t.setPosition(t.position()+W),(s||new lt).__init(t.readInt32(t.position())+t.position(),t)}vertical(t,s){const e=this.bb.__offset(this.bb_pos,4);return e?(s||new As).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+e)+t*4),this.bb):null}verticalLength(){const t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__vector_len(this.bb_pos+t):0}horizontal(t,s){const e=this.bb.__offset(this.bb_pos,6);return e?(s||new As).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+e)+t*4),this.bb):null}horizontalLength(){const t=this.bb.__offset(this.bb_pos,6);return t?this.bb.__vector_len(this.bb_pos+t):0}absolute(t,s){const e=this.bb.__offset(this.bb_pos,8);return e?(s||new As).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+e)+t*4),this.bb):null}absoluteLength(){const t=this.bb.__offset(this.bb_pos,8);return t?this.bb.__vector_len(this.bb_pos+t):0}initialPk(){const t=this.bb.__offset(this.bb_pos,10);return t?this.bb.readFloat32(this.bb_pos+t):0}static startAlignment(t){t.startObject(4)}static addVertical(t,s){t.addFieldOffset(0,s,0)}static createVerticalVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addOffset(s[e]);return t.endVector()}static startVerticalVector(t,s){t.startVector(4,s,4)}static addHorizontal(t,s){t.addFieldOffset(1,s,0)}static createHorizontalVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addOffset(s[e]);return t.endVector()}static startHorizontalVector(t,s){t.startVector(4,s,4)}static addAbsolute(t,s){t.addFieldOffset(2,s,0)}static createAbsoluteVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addOffset(s[e]);return t.endVector()}static startAbsoluteVector(t,s){t.startVector(4,s,4)}static addInitialPk(t,s){t.addFieldFloat32(3,s,0)}static endAlignment(t){return t.endObject()}static createAlignment(t,s,e,i,n){return lt.startAlignment(t),lt.addVertical(t,s),lt.addHorizontal(t,e),lt.addAbsolute(t,i),lt.addInitialPk(t,n),lt.endAlignment(t)}};class ht{constructor(){B(this,"bb",null);B(this,"bb_pos",0)}__init(t,s){return this.bb_pos=t,this.bb=s,this}static getRootAsCivilData(t,s){return(s||new ht).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsCivilData(t,s){return t.setPosition(t.position()+W),(s||new ht).__init(t.readInt32(t.position())+t.position(),t)}alignments(t,s){const e=this.bb.__offset(this.bb_pos,4);return e?(s||new Le).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+e)+t*4),this.bb):null}alignmentsLength(){const t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__vector_len(this.bb_pos+t):0}coordinationMatrix(t){const s=this.bb.__offset(this.bb_pos,6);return s?this.bb.readFloat32(this.bb.__vector(this.bb_pos+s)+t*4):0}coordinationMatrixLength(){const t=this.bb.__offset(this.bb_pos,6);return t?this.bb.__vector_len(this.bb_pos+t):0}coordinationMatrixArray(){const t=this.bb.__offset(this.bb_pos,6);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}static startCivilData(t){t.startObject(2)}static addAlignments(t,s){t.addFieldOffset(0,s,0)}static createAlignmentsVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addOffset(s[e]);return t.endVector()}static startAlignmentsVector(t,s){t.startVector(4,s,4)}static addCoordinationMatrix(t,s){t.addFieldOffset(1,s,0)}static createCoordinationMatrixVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addFloat32(s[e]);return t.endVector()}static startCoordinationMatrixVector(t,s){t.startVector(4,s,4)}static endCivilData(t){return t.endObject()}static createCivilData(t,s,e){return ht.startCivilData(t),ht.addAlignments(t,s),ht.addCoordinationMatrix(t,e),ht.endCivilData(t)}}class N{constructor(){B(this,"bb",null);B(this,"bb_pos",0)}__init(t,s){return this.bb_pos=t,this.bb=s,this}static getRootAsFragment(t,s){return(s||new N).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsFragment(t,s){return t.setPosition(t.position()+W),(s||new N).__init(t.readInt32(t.position())+t.position(),t)}position(t){const s=this.bb.__offset(this.bb_pos,4);return s?this.bb.readFloat32(this.bb.__vector(this.bb_pos+s)+t*4):0}positionLength(){const t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__vector_len(this.bb_pos+t):0}positionArray(){const t=this.bb.__offset(this.bb_pos,4);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}normal(t){const s=this.bb.__offset(this.bb_pos,6);return s?this.bb.readFloat32(this.bb.__vector(this.bb_pos+s)+t*4):0}normalLength(){const t=this.bb.__offset(this.bb_pos,6);return t?this.bb.__vector_len(this.bb_pos+t):0}normalArray(){const t=this.bb.__offset(this.bb_pos,6);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}index(t){const s=this.bb.__offset(this.bb_pos,8);return s?this.bb.readUint32(this.bb.__vector(this.bb_pos+s)+t*4):0}indexLength(){const t=this.bb.__offset(this.bb_pos,8);return t?this.bb.__vector_len(this.bb_pos+t):0}indexArray(){const t=this.bb.__offset(this.bb_pos,8);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}groups(t){const s=this.bb.__offset(this.bb_pos,10);return s?this.bb.readFloat32(this.bb.__vector(this.bb_pos+s)+t*4):0}groupsLength(){const t=this.bb.__offset(this.bb_pos,10);return t?this.bb.__vector_len(this.bb_pos+t):0}groupsArray(){const t=this.bb.__offset(this.bb_pos,10);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}materials(t){const s=this.bb.__offset(this.bb_pos,12);return s?this.bb.readFloat32(this.bb.__vector(this.bb_pos+s)+t*4):0}materialsLength(){const t=this.bb.__offset(this.bb_pos,12);return t?this.bb.__vector_len(this.bb_pos+t):0}materialsArray(){const t=this.bb.__offset(this.bb_pos,12);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}matrices(t){const s=this.bb.__offset(this.bb_pos,14);return s?this.bb.readFloat32(this.bb.__vector(this.bb_pos+s)+t*4):0}matricesLength(){const t=this.bb.__offset(this.bb_pos,14);return t?this.bb.__vector_len(this.bb_pos+t):0}matricesArray(){const t=this.bb.__offset(this.bb_pos,14);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}colors(t){const s=this.bb.__offset(this.bb_pos,16);return s?this.bb.readFloat32(this.bb.__vector(this.bb_pos+s)+t*4):0}colorsLength(){const t=this.bb.__offset(this.bb_pos,16);return t?this.bb.__vector_len(this.bb_pos+t):0}colorsArray(){const t=this.bb.__offset(this.bb_pos,16);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}itemsSize(t){const s=this.bb.__offset(this.bb_pos,18);return s?this.bb.readUint32(this.bb.__vector(this.bb_pos+s)+t*4):0}itemsSizeLength(){const t=this.bb.__offset(this.bb_pos,18);return t?this.bb.__vector_len(this.bb_pos+t):0}itemsSizeArray(){const t=this.bb.__offset(this.bb_pos,18);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}ids(t){const s=this.bb.__offset(this.bb_pos,20);return s?this.bb.readUint32(this.bb.__vector(this.bb_pos+s)+t*4):0}idsLength(){const t=this.bb.__offset(this.bb_pos,20);return t?this.bb.__vector_len(this.bb_pos+t):0}idsArray(){const t=this.bb.__offset(this.bb_pos,20);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}id(t){const s=this.bb.__offset(this.bb_pos,22);return s?this.bb.__string(this.bb_pos+s,t):null}capacity(){const t=this.bb.__offset(this.bb_pos,24);return t?this.bb.readUint32(this.bb_pos+t):0}capacityOffset(){const t=this.bb.__offset(this.bb_pos,26);return t?this.bb.readUint32(this.bb_pos+t):0}static startFragment(t){t.startObject(12)}static addPosition(t,s){t.addFieldOffset(0,s,0)}static createPositionVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addFloat32(s[e]);return t.endVector()}static startPositionVector(t,s){t.startVector(4,s,4)}static addNormal(t,s){t.addFieldOffset(1,s,0)}static createNormalVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addFloat32(s[e]);return t.endVector()}static startNormalVector(t,s){t.startVector(4,s,4)}static addIndex(t,s){t.addFieldOffset(2,s,0)}static createIndexVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addInt32(s[e]);return t.endVector()}static startIndexVector(t,s){t.startVector(4,s,4)}static addGroups(t,s){t.addFieldOffset(3,s,0)}static createGroupsVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addFloat32(s[e]);return t.endVector()}static startGroupsVector(t,s){t.startVector(4,s,4)}static addMaterials(t,s){t.addFieldOffset(4,s,0)}static createMaterialsVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addFloat32(s[e]);return t.endVector()}static startMaterialsVector(t,s){t.startVector(4,s,4)}static addMatrices(t,s){t.addFieldOffset(5,s,0)}static createMatricesVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addFloat32(s[e]);return t.endVector()}static startMatricesVector(t,s){t.startVector(4,s,4)}static addColors(t,s){t.addFieldOffset(6,s,0)}static createColorsVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addFloat32(s[e]);return t.endVector()}static startColorsVector(t,s){t.startVector(4,s,4)}static addItemsSize(t,s){t.addFieldOffset(7,s,0)}static createItemsSizeVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addInt32(s[e]);return t.endVector()}static startItemsSizeVector(t,s){t.startVector(4,s,4)}static addIds(t,s){t.addFieldOffset(8,s,0)}static createIdsVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addInt32(s[e]);return t.endVector()}static startIdsVector(t,s){t.startVector(4,s,4)}static addId(t,s){t.addFieldOffset(9,s,0)}static addCapacity(t,s){t.addFieldInt32(10,s,0)}static addCapacityOffset(t,s){t.addFieldInt32(11,s,0)}static endFragment(t){return t.endObject()}static createFragment(t,s,e,i,n,o,r,c,f,l,b,h,u){return N.startFragment(t),N.addPosition(t,s),N.addNormal(t,e),N.addIndex(t,i),N.addGroups(t,n),N.addMaterials(t,o),N.addMatrices(t,r),N.addColors(t,c),N.addItemsSize(t,f),N.addIds(t,l),N.addId(t,b),N.addCapacity(t,h),N.addCapacityOffset(t,u),N.endFragment(t)}}let ks=class te{constructor(){B(this,"bb",null);B(this,"bb_pos",0)}__init(t,s){return this.bb_pos=t,this.bb=s,this}static getRootAsFragmentsGroup(t,s){return(s||new te).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsFragmentsGroup(t,s){return t.setPosition(t.position()+W),(s||new te).__init(t.readInt32(t.position())+t.position(),t)}items(t,s){const e=this.bb.__offset(this.bb_pos,4);return e?(s||new N).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+e)+t*4),this.bb):null}itemsLength(){const t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__vector_len(this.bb_pos+t):0}civil(t){const s=this.bb.__offset(this.bb_pos,6);return s?(t||new ht).__init(this.bb.__indirect(this.bb_pos+s),this.bb):null}coordinationMatrix(t){const s=this.bb.__offset(this.bb_pos,8);return s?this.bb.readFloat32(this.bb.__vector(this.bb_pos+s)+t*4):0}coordinationMatrixLength(){const t=this.bb.__offset(this.bb_pos,8);return t?this.bb.__vector_len(this.bb_pos+t):0}coordinationMatrixArray(){const t=this.bb.__offset(this.bb_pos,8);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}ids(t){const s=this.bb.__offset(this.bb_pos,10);return s?this.bb.readUint32(this.bb.__vector(this.bb_pos+s)+t*4):0}idsLength(){const t=this.bb.__offset(this.bb_pos,10);return t?this.bb.__vector_len(this.bb_pos+t):0}idsArray(){const t=this.bb.__offset(this.bb_pos,10);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}itemsKeys(t){const s=this.bb.__offset(this.bb_pos,12);return s?this.bb.readUint32(this.bb.__vector(this.bb_pos+s)+t*4):0}itemsKeysLength(){const t=this.bb.__offset(this.bb_pos,12);return t?this.bb.__vector_len(this.bb_pos+t):0}itemsKeysArray(){const t=this.bb.__offset(this.bb_pos,12);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}itemsKeysIndices(t){const s=this.bb.__offset(this.bb_pos,14);return s?this.bb.readUint32(this.bb.__vector(this.bb_pos+s)+t*4):0}itemsKeysIndicesLength(){const t=this.bb.__offset(this.bb_pos,14);return t?this.bb.__vector_len(this.bb_pos+t):0}itemsKeysIndicesArray(){const t=this.bb.__offset(this.bb_pos,14);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}itemsRels(t){const s=this.bb.__offset(this.bb_pos,16);return s?this.bb.readUint32(this.bb.__vector(this.bb_pos+s)+t*4):0}itemsRelsLength(){const t=this.bb.__offset(this.bb_pos,16);return t?this.bb.__vector_len(this.bb_pos+t):0}itemsRelsArray(){const t=this.bb.__offset(this.bb_pos,16);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}itemsRelsIndices(t){const s=this.bb.__offset(this.bb_pos,18);return s?this.bb.readUint32(this.bb.__vector(this.bb_pos+s)+t*4):0}itemsRelsIndicesLength(){const t=this.bb.__offset(this.bb_pos,18);return t?this.bb.__vector_len(this.bb_pos+t):0}itemsRelsIndicesArray(){const t=this.bb.__offset(this.bb_pos,18);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}fragmentKeys(t){const s=this.bb.__offset(this.bb_pos,20);return s?this.bb.__string(this.bb_pos+s,t):null}globalIds(t){const s=this.bb.__offset(this.bb_pos,22);return s?this.bb.__string(this.bb_pos+s,t):null}id(t){const s=this.bb.__offset(this.bb_pos,24);return s?this.bb.__string(this.bb_pos+s,t):null}name(t){const s=this.bb.__offset(this.bb_pos,26);return s?this.bb.__string(this.bb_pos+s,t):null}ifcName(t){const s=this.bb.__offset(this.bb_pos,28);return s?this.bb.__string(this.bb_pos+s,t):null}ifcDescription(t){const s=this.bb.__offset(this.bb_pos,30);return s?this.bb.__string(this.bb_pos+s,t):null}ifcSchema(t){const s=this.bb.__offset(this.bb_pos,32);return s?this.bb.__string(this.bb_pos+s,t):null}maxExpressId(){const t=this.bb.__offset(this.bb_pos,34);return t?this.bb.readUint32(this.bb_pos+t):0}boundingBox(t){const s=this.bb.__offset(this.bb_pos,36);return s?this.bb.readFloat32(this.bb.__vector(this.bb_pos+s)+t*4):0}boundingBoxLength(){const t=this.bb.__offset(this.bb_pos,36);return t?this.bb.__vector_len(this.bb_pos+t):0}boundingBoxArray(){const t=this.bb.__offset(this.bb_pos,36);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}opaqueGeometriesIds(t){const s=this.bb.__offset(this.bb_pos,38);return s?this.bb.readInt32(this.bb.__vector(this.bb_pos+s)+t*4):0}opaqueGeometriesIdsLength(){const t=this.bb.__offset(this.bb_pos,38);return t?this.bb.__vector_len(this.bb_pos+t):0}opaqueGeometriesIdsArray(){const t=this.bb.__offset(this.bb_pos,38);return t?new Int32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}transparentGeometriesIds(t){const s=this.bb.__offset(this.bb_pos,40);return s?this.bb.readInt32(this.bb.__vector(this.bb_pos+s)+t*4):0}transparentGeometriesIdsLength(){const t=this.bb.__offset(this.bb_pos,40);return t?this.bb.__vector_len(this.bb_pos+t):0}transparentGeometriesIdsArray(){const t=this.bb.__offset(this.bb_pos,40);return t?new Int32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}static startFragmentsGroup(t){t.startObject(19)}static addItems(t,s){t.addFieldOffset(0,s,0)}static createItemsVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addOffset(s[e]);return t.endVector()}static startItemsVector(t,s){t.startVector(4,s,4)}static addCivil(t,s){t.addFieldOffset(1,s,0)}static addCoordinationMatrix(t,s){t.addFieldOffset(2,s,0)}static createCoordinationMatrixVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addFloat32(s[e]);return t.endVector()}static startCoordinationMatrixVector(t,s){t.startVector(4,s,4)}static addIds(t,s){t.addFieldOffset(3,s,0)}static createIdsVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addInt32(s[e]);return t.endVector()}static startIdsVector(t,s){t.startVector(4,s,4)}static addItemsKeys(t,s){t.addFieldOffset(4,s,0)}static createItemsKeysVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addInt32(s[e]);return t.endVector()}static startItemsKeysVector(t,s){t.startVector(4,s,4)}static addItemsKeysIndices(t,s){t.addFieldOffset(5,s,0)}static createItemsKeysIndicesVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addInt32(s[e]);return t.endVector()}static startItemsKeysIndicesVector(t,s){t.startVector(4,s,4)}static addItemsRels(t,s){t.addFieldOffset(6,s,0)}static createItemsRelsVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addInt32(s[e]);return t.endVector()}static startItemsRelsVector(t,s){t.startVector(4,s,4)}static addItemsRelsIndices(t,s){t.addFieldOffset(7,s,0)}static createItemsRelsIndicesVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addInt32(s[e]);return t.endVector()}static startItemsRelsIndicesVector(t,s){t.startVector(4,s,4)}static addFragmentKeys(t,s){t.addFieldOffset(8,s,0)}static addGlobalIds(t,s){t.addFieldOffset(9,s,0)}static addId(t,s){t.addFieldOffset(10,s,0)}static addName(t,s){t.addFieldOffset(11,s,0)}static addIfcName(t,s){t.addFieldOffset(12,s,0)}static addIfcDescription(t,s){t.addFieldOffset(13,s,0)}static addIfcSchema(t,s){t.addFieldOffset(14,s,0)}static addMaxExpressId(t,s){t.addFieldInt32(15,s,0)}static addBoundingBox(t,s){t.addFieldOffset(16,s,0)}static createBoundingBoxVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addFloat32(s[e]);return t.endVector()}static startBoundingBoxVector(t,s){t.startVector(4,s,4)}static addOpaqueGeometriesIds(t,s){t.addFieldOffset(17,s,0)}static createOpaqueGeometriesIdsVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addInt32(s[e]);return t.endVector()}static startOpaqueGeometriesIdsVector(t,s){t.startVector(4,s,4)}static addTransparentGeometriesIds(t,s){t.addFieldOffset(18,s,0)}static createTransparentGeometriesIdsVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addInt32(s[e]);return t.endVector()}static startTransparentGeometriesIdsVector(t,s){t.startVector(4,s,4)}static endFragmentsGroup(t){return t.endObject()}static finishFragmentsGroupBuffer(t,s){t.finish(s)}static finishSizePrefixedFragmentsGroupBuffer(t,s){t.finish(s,void 0,!0)}};class $i{constructor(){B(this,"version",2);B(this,"separator","|")}import(t){const s=new Tt(t),e=ks.getRootAsFragmentsGroup(s),i=this.constructFragmentGroup(e),n=e.itemsLength();for(let o=0;o<n;o++){const r=e.items(o);if(!r)continue;const c=this.constructGeometry(r),f=this.constructMaterials(r),l=r.capacity(),b=new ne(c,f,l);b.capacityOffset=r.capacityOffset(),this.setInstances(r,b),this.setID(r,b),i.items.push(b),i.add(b.mesh)}return i}export(t){const s=new is(1024),e=[],i=ks,n=N;let o=null;if(t.civilData){const z=[],U=Le,K=ht;for(const[Ot,_t]of t.civilData.alignments){const{absolute:At,horizontal:vt,vertical:Vt}=_t,Ft=this.saveCivilCurves(vt,s),Ct=this.saveCivilCurves(Vt,s),Mt=this.saveCivilCurves(At,s),pt=U.createHorizontalVector(s,Ft),$t=U.createVerticalVector(s,Ct),ns=U.createAbsoluteVector(s,Mt);U.startAlignment(s),U.addHorizontal(s,pt),U.addVertical(s,$t),U.addAbsolute(s,ns),U.addInitialPk(s,_t.initialKP);const Ue=U.endAlignment(s);z.push(Ue)}const rt=K.createAlignmentsVector(s,z),dt=K.createCoordinationMatrixVector(s,t.coordinationMatrix.elements);K.startCivilData(s),K.addAlignments(s,rt),K.addCoordinationMatrix(s,dt),o=K.endCivilData(s)}for(const z of t.items){const U=z.exportData(),K=[];for(const $t of z.ids){const ns=z.getInstancesIDs($t);if(!ns)throw new Error("Instances not found!");K.push(ns.size)}const rt=n.createPositionVector(s,U.position),dt=n.createNormalVector(s,U.normal),Ot=n.createIndexVector(s,U.index),_t=n.createGroupsVector(s,U.groups),At=n.createMaterialsVector(s,U.materials),vt=n.createMatricesVector(s,U.matrices),Vt=n.createColorsVector(s,U.colors),Ft=n.createIdsVector(s,U.ids),Ct=n.createItemsSizeVector(s,K),Mt=s.createString(U.id);n.startFragment(s),n.addPosition(s,rt),n.addNormal(s,dt),n.addIndex(s,Ot),n.addGroups(s,_t),n.addMaterials(s,At),n.addMatrices(s,vt),n.addColors(s,Vt),n.addIds(s,Ft),n.addItemsSize(s,Ct),n.addId(s,Mt),n.addCapacity(s,z.capacity),n.addCapacityOffset(s,z.capacityOffset);const pt=N.endFragment(s);e.push(pt)}const r=i.createItemsVector(s,e),c=i.createCoordinationMatrixVector(s,t.coordinationMatrix.elements);let f="";for(const z of t.keyFragments.values())f.length&&(f+=this.separator),f+=z;let l="";for(const[z]of t.globalToExpressIDs)l.length&&(l+=this.separator),l+=z;const b=s.createString(f),h=s.createString(l),u=[],_=[],w=[],y=[],d=[];let p=0,I=0;for(const[z,[U,K]]of t.data){u.push(p),w.push(I),d.push(z);for(const rt of U)_.push(rt);for(const rt of K)y.push(rt);p+=U.length,I+=K.length}const m=[],g=[];for(const[z,U]of t.geometryIDs.opaque)m.push(z,U);for(const[z,U]of t.geometryIDs.transparent)g.push(z,U);const A=s.createString(t.uuid),C=s.createString(t.name),x=s.createString(t.ifcMetadata.name),M=s.createString(t.ifcMetadata.description),v=s.createString(t.ifcMetadata.schema),S=i.createItemsKeysIndicesVector(s,u),F=i.createItemsKeysVector(s,_),P=i.createItemsRelsIndicesVector(s,w),T=i.createItemsRelsVector(s,y),O=i.createIdsVector(s,d),D=i.createOpaqueGeometriesIdsVector(s,m),$=i.createTransparentGeometriesIdsVector(s,g),{min:X,max:Y}=t.boundingBox,Ms=[X.x,X.y,X.z,Y.x,Y.y,Y.z],q=i.createBoundingBoxVector(s,Ms);i.startFragmentsGroup(s),i.addId(s,A),i.addName(s,C),i.addIfcName(s,x),i.addIfcDescription(s,M),i.addIfcSchema(s,v),i.addMaxExpressId(s,t.ifcMetadata.maxExpressID),i.addItems(s,r),i.addFragmentKeys(s,b),i.addGlobalIds(s,h),i.addIds(s,O),i.addItemsKeysIndices(s,S),i.addItemsKeys(s,F),i.addItemsRelsIndices(s,P),i.addItemsRels(s,T),i.addCoordinationMatrix(s,c),i.addBoundingBox(s,q),i.addOpaqueGeometriesIds(s,D),i.addTransparentGeometriesIds(s,$),o!==null&&i.addCivil(s,o);const E=ks.endFragmentsGroup(s);return s.finish(E),s.asUint8Array()}setID(t,s){const e=t.id();e&&(s.id=e,s.mesh.uuid=e)}setInstances(t,s){const e=t.matricesArray(),i=t.colorsArray(),n=t.idsArray(),o=t.itemsSizeArray();if(!e||!n||!o)throw new Error("Error: Can't load empty fragment!");const r=[];let c=0;for(let f=0;f<o.length;f++){const l=n[f],b=o[f],h=[],u=[];for(let w=0;w<b;w++){const y=c*16,d=e.subarray(y,y+17),p=new L.Matrix4().fromArray(d);if(h.push(p),i){const I=c*3,[m,g,A]=i.subarray(I,I+4),C=new L.Color(m,g,A);u.push(C)}c++}const _=u.length?u:void 0;r.push({id:l,transforms:h,colors:_})}s.add(r)}constructMaterials(t){const s=t.materialsArray(),e=[];if(!s)return e;for(let i=0;i<s.length;i+=5){const n=s[i],o=!!s[i+1],r=s[i+2],c=s[i+3],f=s[i+4],l=new L.Color(r,c,f),b=new L.MeshLambertMaterial({color:l,opacity:n,transparent:o});e.push(b)}return e}constructFragmentGroup(t){const s=new es,e=t.civil();if(e){const v=e.coordinationMatrixArray(),S=new L.Matrix4;v&&S.fromArray(v),s.civilData={alignments:new Map,coordinationMatrix:S};const F=e.alignmentsLength();for(let P=0;P<F;P++){const T=new L.LineBasicMaterial({color:16777215}),O=new oe,D=e.alignments(P);if(!D)throw new Error("Alignment not found!");const $=D.horizontalLength();O.horizontal=this.constructCivilCurves(D,O,"horizontal",$,T);const X=D.verticalLength();O.vertical=this.constructCivilCurves(D,O,"vertical",X,T);const Y=D.horizontalLength();O.absolute=this.constructCivilCurves(D,O,"absolute",Y,T),O.initialKP=D.initialPk(),s.civilData.alignments.set(P,O)}}s.uuid=t.id()||s.uuid,s.name=t.name()||"",s.ifcMetadata={name:t.ifcName()||"",description:t.ifcDescription()||"",schema:t.ifcSchema()||"IFC2X3",maxExpressID:t.maxExpressId()||0};const i=new L.Matrix4().elements,n=t.coordinationMatrixArray()||i,o=t.idsArray()||new Uint32Array,r=t.itemsKeysIndicesArray()||new Uint32Array,c=t.itemsKeysArray()||new Uint32Array,f=t.itemsRelsArray()||new Uint32Array,l=t.itemsRelsIndicesArray()||new Uint32Array,h=(t.fragmentKeys()||"").split(this.separator),_=(t.globalIds()||"").split(this.separator);this.setGroupData(s,o,r,c,0),this.setGroupData(s,o,l,f,1);const w=t.opaqueGeometriesIdsArray()||new Uint32Array,y=t.transparentGeometriesIdsArray()||new Uint32Array,d=new Map;for(let v=0;v<w.length-1;v+=2){const S=w[v],F=w[v+1];d.set(S,F)}const p=new Map;for(let v=0;v<y.length-1;v+=2){const S=y[v],F=y[v+1];p.set(S,F)}s.geometryIDs={opaque:d,transparent:p};const I=t.boundingBoxArray()||[0,0,0,0,0,0],[m,g,A,C,x,M]=I;s.boundingBox.min.set(m,g,A),s.boundingBox.max.set(C,x,M);for(let v=0;v<h.length;v++)s.keyFragments.set(v,h[v]);n.length===16&&s.coordinationMatrix.fromArray(n);for(let v=0;v<o.length;v++)s.globalToExpressIDs.set(_[v],o[v]);return s}setGroupData(t,s,e,i,n){for(let o=0;o<e.length;o++){const r=s[o],c=e[o],f=e[o+1],l=f===void 0?i.length:f,b=[];for(let u=c;u<l;u++)b.push(i[u]);t.data.has(r)||t.data.set(r,[[],[]]);const h=t.data.get(r);h&&(h[n]=b)}}constructGeometry(t){const s=t.positionArray()||new Float32Array,e=t.normalArray()||new Float32Array,i=t.indexArray(),n=t.groupsArray();if(!i)throw new Error("Index not found!");const o=new L.BufferGeometry;if(o.setIndex(Array.from(i)),o.setAttribute("position",new L.BufferAttribute(s,3)),o.setAttribute("normal",new L.BufferAttribute(e,3)),n)for(let r=0;r<n.length;r+=3){const c=n[r],f=n[r+1],l=n[r+2];o.addGroup(c,f,l)}return o}constructCivilCurves(t,s,e,i,n){const o=[];for(let r=0;r<i;r++){const c=t[e](r);if(!c)throw new Error("Curve not found!");const f=c.pointsArray();if(f===null)throw new Error("Curve points not found!");let l={};const b=c.data();b&&(l=JSON.parse(b));const h=new L.EdgesGeometry,u=new L.BufferAttribute(f,3);h.setAttribute("position",u);const _=[];for(let y=0;y<f.length/3-1;y++)_.push(y,y+1);h.setIndex(_);const w=new re(r,l,s,h,n);o.push(w.curve)}return o}saveCivilCurves(t,s){const e=As,i=[];for(const n of t){const r=n.mesh.geometry.attributes.position.array,c=e.createPointsVector(s,r),f=s.createString(JSON.stringify(n.data));e.startCivilCurve(s),e.addPoints(s,c),e.addData(s,f);const l=e.endCivilCurve(s);i.push(l)}return i}}class Hi{constructor(){B(this,"parsers",[new $i,new Ki]);B(this,"version","auto")}import(t){const s=this.parsers.length;if(this.version==="auto"){for(let o=0;o<this.parsers.length;o++){const c=this.parsers[o].import(t);if(Object.keys(c).length!==0){if(o!==0){const f=this.parsers.length-o;this.warnVersion(f,s)}return c}}throw new Error("No valid parser found for this file")}this.checkCurrentVersionValid(this.version);const e=this.parsers.length-this.version,n=this.parsers[e].import(t);if(Object.keys(n).length===0)throw new Error(`The given version ${this.version} doesn't match to the given file. Try using "auto" in the version property to handle versions automatically.`);return n}export(t){if(this.version==="auto")return this.parsers[0].export(t);this.checkCurrentVersionValid(this.version);const s=this.parsers.length-this.version;return this.parsers[s].export(t)}checkCurrentVersionValid(t){if(this.version==="auto")return;if(this.version!==t&&this.warnVersion(this.version,t),!Number.isInteger(this.version))throw new Error("Invalid version. Non-automatic versions must an integer.");if(this.version<1||this.version>t)throw new Error(`Invalid version. Versions range from 1 to ${t}.`)}warnVersion(t,s){console.warn(`This fragment file version is ${t}. The latest version is ${s}. To avoid issues, please consider updating your fragments. You can do so by regenerating your fragments from the original IFC file.`)}}const ss=class ss extends L.Group{constructor(){super(...arguments);B(this,"items",[]);B(this,"boundingBox",new L.Box3);B(this,"coordinationMatrix",new L.Matrix4);B(this,"keyFragments",new Map);B(this,"globalToExpressIDs",new Map);B(this,"data",new Map);B(this,"geometryIDs",{opaque:new Map,transparent:new Map});B(this,"ifcMetadata",{name:"",description:"",schema:"IFC2X3",maxExpressID:0});B(this,"civilData");B(this,"streamSettings",{baseUrl:"",baseFileName:"",ids:new Map,types:new Map});B(this,"isStreamed",!1);B(this,"_properties")}get hasProperties(){const s=this._properties!==void 0,e=this.streamSettings.ids.size!==0;return s||e}getFragmentMap(s){const e={};for(const i of s){const n=this.data.get(i);if(n)for(const o of n[0]){const r=this.keyFragments.get(o);r!==void 0&&(e[r]||(e[r]=new Set),e[r].add(i))}}return e}getItemVertices(s){const e=[],i=this.getFragmentMap([s]);for(const n in i){const o=this.items.find(c=>c.id===n);if(!o)continue;const r=o.getInstancesIDs(s);if(r)for(const c of r){const f=new L.Matrix4;o.mesh.getMatrixAt(c,f);for(const l of o.uniqueVertices){const b=l.clone().applyMatrix4(f);e.push(b)}}}return e}dispose(s=!0){for(const e of this.items)e.dispose(s);if(this.coordinationMatrix=new L.Matrix4,this.keyFragments.clear(),this.data.clear(),this._properties={},this.removeFromParent(),this.items=[],this.civilData){const{alignments:e}=this.civilData;for(const[i,n]of e)this.disposeAlignment(n.vertical),this.disposeAlignment(n.horizontal),this.disposeAlignment(n.absolute)}this.civilData=void 0}setLocalProperties(s){this._properties=s}getLocalProperties(){return this._properties}getAllPropertiesIDs(){return this._properties?Object.keys(this._properties).map(s=>parseInt(s,10)):Array.from(this.streamSettings.ids.keys())}getAllPropertiesTypes(){if(this._properties){const s=new Set;for(const e in this._properties){const i=this._properties[e];i.type!==void 0&&s.add(i.type)}return Array.from(s)}return Array.from(this.streamSettings.types.keys())}async getProperties(s){if(this._properties)return this._properties[s]||null;const e=this.getPropsURL(s),i=await this.getPropertiesData(e);return i?i[s]:null}async setProperties(s,e){if(this._properties){e!==null?this._properties[s]=e:delete this._properties[s];return}throw new Error("Writing streamed properties not supported yet!")}async getAllPropertiesOfType(s){if(this._properties){const o={};let r=!1;for(const c in this._properties){const f=this._properties[c];f.type===s&&(o[f.expressID]=f,r=!0)}return r?o:null}const{types:e}=this.streamSettings,i=e.get(s);if(i===void 0)return null;const n={};for(const o of i){const r=this.constructFileName(o),c=this.constructURL(r),f=await this.getPropertiesData(c);for(const l in f)n[parseInt(l,10)]=f[l]}return n}clone(s){throw new Error("Use FragmentsGroup.cloneGroup instead!")}cloneGroup(s){const e=new ss;e.coordinationMatrix=this.coordinationMatrix,e.position.copy(this.position),e.rotation.copy(this.rotation),e.scale.copy(this.scale),e.updateMatrix(),e.ifcMetadata={...this.ifcMetadata},s||(s=this.getFragmentMap(this.data.keys()));const i=new Set,n=new Map;for(const o of this.items){if(!s[o.id])continue;const r=s[o.id],c=o.clone(r);n.set(o.id,c.id),e.items.push(c),e.add(c.mesh);for(const f of r)i.add(f)}for(const o of i){const r=this.data.get(o);r&&e.data.set(o,r)}for(const[o,r]of this.keyFragments)if(n.has(r)){const c=n.get(r);if(c===void 0)throw new Error("Malformed fragment ID map during clone!");e.keyFragments.set(o,c)}for(const[o,r]of this.globalToExpressIDs)i.has(r)&&e.globalToExpressIDs.set(o,r);return this.civilData&&(e.civilData={coordinationMatrix:this.coordinationMatrix,alignments:new Map}),e}getPropsURL(s){const{ids:e}=this.streamSettings,i=e.get(s);if(i===void 0)throw new Error("ID not found");const n=this.constructFileName(i);return this.constructURL(n)}async getPropertiesData(s){const e=await ss.fetch(s);if(e.json)return e.json();if(e.text){const i=await e.text();return JSON.parse(i)}throw new Error("Invalid response type when getting properties data.")}constructFileName(s){const{baseFileName:e}=this.streamSettings;return`${e}-${s}`}constructURL(s){const{baseUrl:e}=this.streamSettings;return`${e}${s}`}disposeAlignment(s){for(const e of s)if(e.mesh.geometry.dispose(),Array.isArray(e.mesh.material))for(const i of e.mesh.material)i.dispose();else e.mesh.material.dispose();s.length=0}};B(ss,"fetch",async s=>fetch(s));let es=ss;class oe{constructor(){B(this,"vertical",[]);B(this,"horizontal",[]);B(this,"absolute",[]);B(this,"initialKP",0)}getLength(t){let s=0;for(const e of this[t])s+=e.getLength();return s}getPointAt(t,s){const e=this.getCurveAt(t,s);return e.curve.getPointAt(e.percentage)}getPercentageAt(t,s,e=.01){const i=this[s];let n=0;for(const o of i){const r=o.getPercentageAt(t,e),c=o.getLength();if(r!==null){const f=n+r*c,l=this.getLength(s);return f/l}n+=c}return null}getCurveAt(t,s){t<0?t=0:t>1&&(t=1);const e=this[s],n=this.getLength(s)*t;let o=0;for(const r of e){const c=r.getLength();if(o+c>=n){const l=(n-o)/c;return{curve:r,percentage:l}}o+=c}throw new Error("Could not compute point!")}}class De{constructor(t,s,e,i){B(this,"index");B(this,"mesh");B(this,"data");B(this,"alignment");this.index=t,this.mesh=s,this.data=e,this.alignment=i}get _index(){return this.mesh.geometry.index}get _pos(){return this.mesh.geometry.attributes.position.array}getLength(){let t=0;for(let s=0;s<this._index.array.length-1;s+=2){const{startPoint:e,endPoint:i}=this.getSegment(s);t+=e.distanceTo(i)}return t}getPointAt(t){const{startPoint:s,endPoint:e,distanceToStart:i}=this.getSegmentAt(t),n=e.clone();return n.sub(s),n.normalize(),n.multiplyScalar(i),n.add(s),n}getSegmentAt(t){t<0?t=0:t>1&&(t=1);const e=this.getLength()*t;let i=0;for(let n=0;n<this._index.array.length-1;n+=2){const{startPoint:o,endPoint:r}=this.getSegment(n),c=o.distanceTo(r);if(i+c>=e)return{distanceToStart:e-i,index:n,startPoint:o,endPoint:r};i+=c}throw new Error("Could not compute point")}getPercentageAt(t,s=.01){let e=0;for(let i=0;i<this._index.array.length-1;i+=2){const{startPoint:n,endPoint:o}=this.getSegment(i),r=n.distanceTo(o),c=t.distanceTo(n),f=t.distanceTo(o);if(c+f-r<=s){const h=e+c,u=this.getLength();return h/u}e+=r}return null}getSegment(t){const s=this._index.array[t]*3,e=this._index.array[t+1]*3,i=new L.Vector3(this._pos[s],this._pos[s+1],this._pos[s+2]),n=new L.Vector3(this._pos[e],this._pos[e+1],this._pos[e+2]);return{startPoint:i,endPoint:n}}}class re extends L.LineSegments{constructor(s,e,i,n,o){super(n,o);B(this,"curve");this.curve=new De(s,this,e,i)}}class nt{constructor(){B(this,"bb",null);B(this,"bb_pos",0)}__init(t,s){return this.bb_pos=t,this.bb=s,this}static getRootAsStreamedGeometry(t,s){return(s||new nt).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsStreamedGeometry(t,s){return t.setPosition(t.position()+W),(s||new nt).__init(t.readInt32(t.position())+t.position(),t)}geometryId(){const t=this.bb.__offset(this.bb_pos,4);return t?this.bb.readUint32(this.bb_pos+t):0}position(t){const s=this.bb.__offset(this.bb_pos,6);return s?this.bb.readFloat32(this.bb.__vector(this.bb_pos+s)+t*4):0}positionLength(){const t=this.bb.__offset(this.bb_pos,6);return t?this.bb.__vector_len(this.bb_pos+t):0}positionArray(){const t=this.bb.__offset(this.bb_pos,6);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}normal(t){const s=this.bb.__offset(this.bb_pos,8);return s?this.bb.readFloat32(this.bb.__vector(this.bb_pos+s)+t*4):0}normalLength(){const t=this.bb.__offset(this.bb_pos,8);return t?this.bb.__vector_len(this.bb_pos+t):0}normalArray(){const t=this.bb.__offset(this.bb_pos,8);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}index(t){const s=this.bb.__offset(this.bb_pos,10);return s?this.bb.readUint32(this.bb.__vector(this.bb_pos+s)+t*4):0}indexLength(){const t=this.bb.__offset(this.bb_pos,10);return t?this.bb.__vector_len(this.bb_pos+t):0}indexArray(){const t=this.bb.__offset(this.bb_pos,10);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}static startStreamedGeometry(t){t.startObject(4)}static addGeometryId(t,s){t.addFieldInt32(0,s,0)}static addPosition(t,s){t.addFieldOffset(1,s,0)}static createPositionVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addFloat32(s[e]);return t.endVector()}static startPositionVector(t,s){t.startVector(4,s,4)}static addNormal(t,s){t.addFieldOffset(2,s,0)}static createNormalVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addFloat32(s[e]);return t.endVector()}static startNormalVector(t,s){t.startVector(4,s,4)}static addIndex(t,s){t.addFieldOffset(3,s,0)}static createIndexVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addInt32(s[e]);return t.endVector()}static startIndexVector(t,s){t.startVector(4,s,4)}static endStreamedGeometry(t){return t.endObject()}static createStreamedGeometry(t,s,e,i,n){return nt.startStreamedGeometry(t),nt.addGeometryId(t,s),nt.addPosition(t,e),nt.addNormal(t,i),nt.addIndex(t,n),nt.endStreamedGeometry(t)}}class It{constructor(){B(this,"bb",null);B(this,"bb_pos",0)}__init(t,s){return this.bb_pos=t,this.bb=s,this}static getRootAsStreamedGeometries(t,s){return(s||new It).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsStreamedGeometries(t,s){return t.setPosition(t.position()+W),(s||new It).__init(t.readInt32(t.position())+t.position(),t)}geometries(t,s){const e=this.bb.__offset(this.bb_pos,4);return e?(s||new nt).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+e)+t*4),this.bb):null}geometriesLength(){const t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__vector_len(this.bb_pos+t):0}static startStreamedGeometries(t){t.startObject(1)}static addGeometries(t,s){t.addFieldOffset(0,s,0)}static createGeometriesVector(t,s){t.startVector(4,s.length,4);for(let e=s.length-1;e>=0;e--)t.addOffset(s[e]);return t.endVector()}static startGeometriesVector(t,s){t.startVector(4,s,4)}static endStreamedGeometries(t){return t.endObject()}static finishStreamedGeometriesBuffer(t,s){t.finish(s)}static finishSizePrefixedStreamedGeometriesBuffer(t,s){t.finish(s,void 0,!0)}static createStreamedGeometries(t,s){return It.startStreamedGeometries(t),It.addGeometries(t,s),It.endStreamedGeometries(t)}}class Xi{import(t){const s=new Tt(t),e=It.getRootAsStreamedGeometries(s),i=new Map,n=e.geometriesLength();for(let o=0;o<n;o++){const r=e.geometries(o);if(!r)continue;const c=r.geometryId();if(c===null)throw new Error("Error finding ID!");const f=r.positionArray(),l=r.normalArray(),b=r.indexArray();!f||!l||!b||i.set(c,{position:f,normal:l,index:b})}return i}export(t){const s=new is(1024),e=[],i=It,n=nt;for(const[c,{index:f,position:l,normal:b}]of t){const h=n.createIndexVector(s,f),u=n.createPositionVector(s,l),_=n.createNormalVector(s,b);n.startStreamedGeometry(s),n.addGeometryId(s,c),n.addIndex(s,h),n.addPosition(s,u),n.addNormal(s,_);const w=n.endStreamedGeometry(s);e.push(w)}const o=i.createGeometriesVector(s,e);i.startStreamedGeometries(s),i.addGeometries(s,o);const r=i.endStreamedGeometries(s);return s.finish(r),s.asUint8Array()}}exports.Alignment=oe;exports.CivilCurve=De;exports.CurveMesh=re;exports.Fragment=ne;exports.FragmentMesh=qs;exports.FragmentsGroup=es;exports.Serializer=Hi;exports.StreamSerializer=Xi;
